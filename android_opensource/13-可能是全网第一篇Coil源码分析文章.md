> å…¬ä¼—å·ï¼š[å­—èŠ‚æ•°ç»„](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adbc507fc3704fd8955aae739a433db2~tplv-k3u1fbpfcp-zoom-1.image)
>
> å¸Œæœ›å¯¹ä½ æœ‰æ‰€å¸®åŠ© ğŸ¤£ğŸ¤£

> å¯¹äº Android Developer æ¥è¯´ï¼Œå¾ˆå¤šå¼€æºåº“éƒ½æ˜¯å±äº**å¼€å‘å¿…å¤‡**çš„çŸ¥è¯†ç‚¹ï¼Œä»ä½¿ç”¨æ–¹å¼åˆ°å®ç°åŸç†å†åˆ°æºç è§£æï¼Œè¿™äº›éƒ½éœ€è¦æˆ‘ä»¬æœ‰ä¸€å®šç¨‹åº¦çš„äº†è§£å’Œè¿ç”¨èƒ½åŠ›ã€‚æ‰€ä»¥æˆ‘æ‰“ç®—æ¥å†™ä¸€ç³»åˆ—å…³äºå¼€æºåº“**æºç è§£æ**å’Œ**å®æˆ˜æ¼”ç»ƒ**çš„æ–‡ç« ï¼Œåˆå®šçš„ç›®æ ‡æ˜¯ **EventBusã€ARouterã€LeakCanaryã€Retrofitã€Glideã€OkHttpã€Coil** ç­‰ä¸ƒä¸ªçŸ¥åå¼€æºåº“ï¼Œå¸Œæœ›å¯¹ä½ æœ‰æ‰€å¸®åŠ© ğŸ¤£ğŸ¤£

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/259d24d1611d454ea49d453844377df2~tplv-k3u1fbpfcp-zoom-1.image)

Coil æ˜¯æˆ‘æœ€åä¸€ä¸ªè¦æ¥åˆ†æçš„å¼€æºåº“ï¼Œæœ¬ç¯‡ä¹Ÿæ˜¯æˆ‘ **Android ä¸»æµå¼€æºåº“æºç åˆ†æ** è¿™ä¸ªç³»åˆ—çš„æœ€åä¸€ç¯‡æ–‡ç« ï¼ŒåŒ…å« Coil çš„å…¥é—¨ä»‹ç»å’Œæºç åˆ†æã€‚è¿™ä¸€ä¸ªç³»åˆ—çš„æ–‡ç« ä»åŠ¨ç¬”åˆ°ç»“æŸèŠ±äº†è¦ä¸¤ä¸ªæœˆæ—¶é—´ï¼Œåˆ°ä»Šå¤©ä¹Ÿå°±ç»“å°¾äº†ï¼ŒåŸåˆ›ä¸æ˜“ï¼Œè§‰å¾—æœ‰ç”¨å°±è¯·ç»™ä¸ªèµå§ ğŸ˜‚ğŸ˜‚ğŸ˜‚

Coil è¿™ä¸ªå¼€æºåº“æˆ‘å…³æ³¨äº†è›®ä¹…çš„ï¼Œå› ä¸ºå…¶å¾ˆå¤šç‰¹æ€§åœ¨æˆ‘çœ‹æ¥éƒ½æŒºæœ‰æ„æ€çš„ã€‚Coil åœ¨ 2020 å¹´ 10 æœˆ 22 æ—¥æ‰å‘å¸ƒäº† 1.0.0 ç‰ˆæœ¬ï¼Œæˆ‘å½“æ—¶åœ¨ç½‘ä¸Šæœäº†æœ Coil çš„èµ„æ–™ï¼Œçœ‹åˆ°çš„æ–‡ç« éƒ½åªæ˜¯å…¥é—¨ä»‹ç»ï¼Œæ²¡çœ‹è§åˆ°å…³äºæºç å±‚æ¬¡çš„åˆ†æï¼Œè€Œæœ¬æ–‡çš„å‘è¡¨æ—¶é—´ç¦» 1.0.0 ç‰ˆæœ¬å‘å¸ƒåˆšå¥½æ‰éš”äº†ä¸€ä¸ªæœˆæ—¶é—´ï¼Œåº”è¯¥æ²¡äººæ¯”æˆ‘è¿˜æ—©äº†å§ï¼Ÿå°±æ–—èƒ†ç»™æ–‡ç« èµ·äº†è¿™ä¹ˆä¸ªæ ‡é¢˜ï¼š**å¯èƒ½æ˜¯å…¨ç½‘ç¬¬ä¸€ç¯‡ Coil æºç åˆ†ææ–‡ç« ** ~

# ä¸€ã€Coil æ˜¯ä»€ä¹ˆ

[Coil](https://github.com/coil-kt/coil) æ˜¯ä¸€ä¸ªæ–°å…´çš„ Android å›¾ç‰‡åŠ è½½åº“ï¼Œä½¿ç”¨ Kotlin åç¨‹æ¥åŠ è½½å›¾ç‰‡ï¼Œæœ‰ä»¥ä¸‹å‡ ä¸ªç‰¹ç‚¹ï¼š

- **æ›´å¿«**: Coil åœ¨æ€§èƒ½ä¸Šåšäº†å¾ˆå¤šä¼˜åŒ–ï¼ŒåŒ…æ‹¬å†…å­˜ç¼“å­˜å’Œç£ç›˜ç¼“å­˜ã€å¯¹å†…å­˜ä¸­çš„å›¾ç‰‡è¿›è¡Œé‡‡æ ·ã€å¤ç”¨ Bitmapã€æ”¯æŒæ ¹æ®ç”Ÿå‘½å‘¨æœŸå˜åŒ–è‡ªåŠ¨æš‚åœå’Œå–æ¶ˆå›¾ç‰‡è¯·æ±‚ç­‰
- **æ›´è½»é‡çº§**: Coil å¤§çº¦ä¼šç»™ä½ çš„ App å¢åŠ ä¸¤åƒä¸ªæ–¹æ³•ï¼ˆå‰ææ˜¯ä½ çš„ App å·²ç»é›†æˆäº† OkHttp å’Œ Coroutinesï¼‰ï¼ŒCoil çš„æ–¹æ³•æ•°å’Œ Picasso ç›¸å½“ï¼Œç›¸æ¯” Glide å’Œ Fresco è¦è½»é‡çº§å¾ˆå¤š
- **æ›´å®¹æ˜“ä½¿ç”¨**: Coil's API å……åˆ†åˆ©ç”¨äº† Kotlin è¯­è¨€çš„æ–°ç‰¹æ€§ï¼Œç®€åŒ–å¹¶å‡å°‘äº†å¾ˆå¤šé‡å¤ä»£ç 
- **æ›´æµè¡Œ**: Coil é¦–é€‰ Kotlin è¯­è¨€å¼€å‘ï¼Œå¹¶ä¸”ä½¿ç”¨åŒ…å« Coroutinesã€OkHttpã€Okio å’Œ AndroidX Lifecycles åœ¨å†…çš„æ›´ç°ä»£åŒ–çš„å¼€æºåº“

Coil çš„é¦–å­—æ¯ç”±æ¥ï¼š**Co**routineï¼Œ**I**mage å’Œ **L**oader å¾—åˆ° Coil

# äºŒã€å¼•å…¥ Coil

Coil è¦æ±‚ **AndroidXã€Min SDK 14+ã€Java 8+** ç¯å¢ƒ

è¦å¯ç”¨ Java 8ï¼Œéœ€è¦åœ¨é¡¹ç›®çš„ Gradle æ„å»ºè„šæœ¬ä¸­æ·»åŠ å¦‚ä¸‹é…ç½®ï¼š

Gradle (`.gradle`)ï¼š

```groovy
compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
}

kotlinOptions {
    jvmTarget = "1.8"
}
```

Gradle Kotlin DSL (`.gradle.kts`)ï¼š

```groovy
compileOptions {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}

kotlinOptions {
    jvmTarget = "1.8"
}
```

Coil ä¸€å…±åŒ…å«äº”ä¸ªç»„ä»¶ï¼Œå¯ä»¥åœ¨ `mavenCentral()`ä¸Šè·å–åˆ°

- `io.coil-kt:coil-base`ã€‚åŸºç¡€ç»„ä»¶ï¼Œæä¾›äº†åŸºæœ¬çš„å›¾ç‰‡è¯·æ±‚ã€å›¾ç‰‡è§£ç ã€å›¾ç‰‡ç¼“å­˜ã€Bitmap å¤ç”¨ç­‰åŠŸèƒ½
- `io.coil-kt:coil`ã€‚é»˜è®¤ç»„ä»¶ï¼Œä¾èµ–äº`io.coil-kt:coil-base`ï¼Œæä¾›äº† Coil ç±»çš„å•ä¾‹å¯¹è±¡ä»¥åŠ ImageView ç›¸å…³çš„æ‰©å±•å‡½æ•°
- `io.coil-kt:coil-gif`ã€‚åŒ…å«ä¸¤ä¸ª [decoder](https://coil-kt.github.io/coil/api/coil-base/coil.decode/-decoder/) ç”¨äºæ”¯æŒè§£ç  GIFsï¼Œæœ‰å…³æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚è§ [GIF](https://coil-kt.github.io/coil/gifs/)
- `io.coil-kt:coil-svg`ã€‚åŒ…å«ä¸€ä¸ª [decoder](https://coil-kt.github.io/coil/api/coil-base/coil.decode/-decoder) ç”¨äºæ”¯æŒè§£ç  SVGã€‚æœ‰å…³æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚è§ [SVG](https://coil-kt.github.io/coil/svgs/)
- `io.coil-kt:coil-video`ã€‚åŒ…å«ä¸¤ä¸ª [fetchers](https://coil-kt.github.io/coil/api/coil-base/coil.fetch/-fetcher) ç”¨äºæ”¯æŒè¯»å–å’Œè§£ç  [ä»»ä½• Android çš„æ”¯æŒçš„è§†é¢‘æ ¼å¼](https://developer.android.com/guide/topics/media/media-formats#video-codecs) çš„è§†é¢‘å¸§ã€‚æœ‰å…³æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚è§ [videos](https://coil-kt.github.io/coil/videos/)

å¼•å…¥å¦‚ä¸‹ä¾èµ–å°±åŒ…å«äº† Coil æœ€åŸºç¡€çš„å›¾ç‰‡åŠ è½½åŠŸèƒ½

```kotlin
implementation("io.coil-kt:coil:1.0.0")
```

å¦‚æœæƒ³è¦æ˜¾ç¤º **Gifã€SVGã€è§†é¢‘å¸§**ç­‰ç±»å‹çš„å›¾ç‰‡ï¼Œåˆ™éœ€è¦é¢å¤–å¼•å…¥å¯¹åº”çš„æ”¯æŒåº“ï¼š

```kotlin
implementation("io.coil-kt:coil-gif:1.0.0")
implementation("io.coil-kt:coil-svg:1.0.0")
implementation("io.coil-kt:coil-video:1.0.0")
```

# ä¸‰ã€å¿«é€Ÿå…¥é—¨

## 1ã€load

è¦å°†å›¾ç‰‡æ˜¾ç¤ºåˆ° ImageView ä¸Šï¼Œç›´æ¥ä½¿ç”¨`ImageView`çš„æ‰©å±•å‡½æ•°`load`å³å¯

```kotlin
// URL
imageView.load("https://www.example.com/image.jpg")

// Resource
imageView.load(R.drawable.image)

// File
imageView.load(File("/path/to/image.jpg"))

// And more...
```

ä½¿ç”¨å¯é€‰çš„ lambda å—æ¥æ·»åŠ é…ç½®é¡¹

```kotlin
imageView.load("https://www.example.com/image.jpg") {
    crossfade(true) //æ·¡å…¥æ·¡å‡º
    placeholder(R.drawable.image) //å ä½å›¾
    transformations(CircleCropTransformation()) //å›¾ç‰‡å˜æ¢ï¼Œå°†å›¾ç‰‡è½¬ä¸ºåœ†å½¢
}
```

## 2ã€ImageRequest

å¦‚æœè¦å°†å›¾ç‰‡åŠ è½½åˆ°è‡ªå®šä¹‰çš„ target ä¸­ï¼Œå¯ä»¥é€šè¿‡ ImageRequest.Builder æ¥æ„å»º ImageRequest å®ä¾‹ï¼Œå¹¶å°†è¯·æ±‚æäº¤ç»™ ImageLoader

```kotlin
val request = ImageRequest.Builder(context)
    .data("https://www.example.com/image.jpg")
    .target { drawable ->
        // Handle the result.
    }
    .build()
context.imageLoader.enqueue(request)
```

## 3ã€ImageLoader

`imageView.load`ä½¿ç”¨å•ä¾‹å¯¹è±¡ imageLoader æ¥æ‰§è¡Œ ImageRequestï¼Œå¯ä»¥ä½¿ç”¨ Context çš„æ‰©å±•å‡½æ•°æ¥è®¿é—® ImageLoader

```kotlin
val imageLoader = context.imageLoader
```

å¯é€‰åœ°ï¼Œä½ ä¹Ÿå¯ä»¥æ„å»ºè‡ªå·±çš„ ImageLoader å®ä¾‹ï¼Œå¹¶èµ‹å€¼ç»™ Coil æ¥å®ç°å…¨å±€ä½¿ç”¨

```kotlin
Coil.setImageLoader(
    ImageLoader.Builder(application)
        .placeholder(ActivityCompat.getDrawable(application, R.drawable.icon_loading))
        .error(ActivityCompat.getDrawable(application, R.drawable.icon_error))
        .build()
)
```

## 4ã€execute

å¦‚æœæƒ³ç›´æ¥æ‹¿åˆ°ç›®æ ‡å›¾ç‰‡ï¼Œå¯ä»¥è°ƒç”¨ ImageLoader çš„`execute`æ–¹æ³•æ¥å®ç°

```kotlin
val request = ImageRequest.Builder(context)
    .data("https://www.example.com/image.jpg")
    .build()
val drawable = imageLoader.execute(request).drawable
```

## 5ã€R8 / Proguard

Coil å¼€ç®±å³ç”¨ï¼Œä¸ R8 å®Œå…¨å…¼å®¹ï¼Œä¸éœ€è¦æ·»åŠ ä»»ä½•é¢å¤–è§„åˆ™

å¦‚æœä½ ä½¿ç”¨äº† Proguardï¼Œä½ å¯èƒ½éœ€è¦æ·»åŠ å¯¹åº”çš„æ··æ·†è§„åˆ™ï¼š[Coroutines](https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/resources/META-INF/proguard/coroutines.pro)ã€[OkHttp](https://github.com/square/okhttp/blob/master/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro) and [Okio](https://github.com/square/okio/blob/master/okio/src/jvmMain/resources/META-INF/proguard/okio.pro)ã€‚

## 6ã€License

```groovy
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
```

# å››ã€å¤§ä½“æ¡†æ¶

Coil åœ¨æˆ‘çœ‹æ¥æ˜¯ä¸€ä¸ªæ¯”è¾ƒâ€œ**æ¿€è¿›**â€çš„å¼€æºåº“ï¼Œçƒ­è¡·äºä½¿ç”¨å½“å‰æœ€ä¸ºæµè¡Œçš„æŠ€æœ¯ï¼ŒåŒ…æ‹¬ Coroutinesã€OkHttpã€Okioï¼Œä»¥åŠ Google å®˜æ–¹çš„ Jetpack Lifecyclesã€AndroidX ç­‰ï¼Œä»£ç ä¸ä»…å®Œå…¨ç”± Kotlin è¯­è¨€æ¥å®ç°ï¼Œè¿ gradle è„šæœ¬ä¹Ÿæ˜¯å…¨éƒ¨ä½¿ç”¨ ktsï¼Œè€Œä¸” gradle ç‰ˆæœ¬ä¹Ÿå‡çº§å¾—å¾ˆå¿«ï¼Œæˆ‘ä¸€å¼€å§‹ç”±äºä½¿ç”¨çš„ Android Studio ä¸æ˜¯ 4.x ç‰ˆæœ¬ï¼Œè¿ Coil ä»£ç éƒ½è·‘ä¸èµ·æ¥ =_=

**å¦‚æœä½ çš„é¡¹ç›®ä¸­å·²ç»å¤§é¢ç§¯ä½¿ç”¨åˆ°äº† Jetpackã€Kotlin Coroutinesã€OkHttp çš„è¯ï¼Œé‚£ä¹ˆ Coil ä¼šæ›´åŠ å¥‘åˆä½ çš„é¡¹ç›®**

å½“å‰åœ¨ Android ç«¯æœ€ä¸ºæµè¡Œçš„å›¾ç‰‡åŠ è½½æ¡†æ¶åº”è¯¥æ˜¯ Glide äº†ï¼ŒCoil ä½œä¸ºä¸€ä¸ªåèµ·ä¹‹ç§€ç›¸å¯¹ Glide ä¹Ÿæœ‰ç€ä¸€äº›ç‹¬ç‰¹çš„ä¼˜åŠ¿ã€‚ä¾‹å¦‚ï¼Œä¸ºäº†ç›‘å¬ UI å±‚çš„ç”Ÿå‘½å‘¨æœŸå˜åŒ–ï¼ŒGlide æ˜¯é€šè¿‡å‘ Activity æˆ–è€… Fragment æ³¨å…¥ä¸€ä¸ªæ—  UI ç•Œé¢çš„ Fragment æ¥å®ç°é—´æ¥ç›‘å¬çš„ï¼Œè€Œ Coil åˆ™åªéœ€è¦ç›´æ¥ç›‘å¬ Lifecycle å³å¯ï¼Œåœ¨å®ç°æ–¹å¼ä¸Š Coil ä¼šæ›´åŠ ç®€å•é«˜æ•ˆã€‚æ­¤å¤–ï¼Œåœ¨è”ç½‘è¯·æ±‚å›¾ç‰‡çš„æ—¶å€™ï¼ŒGlide éœ€è¦é€šè¿‡çº¿ç¨‹æ± å’Œå¤šä¸ªå›è°ƒæ¥å®Œæˆæœ€ç»ˆå›¾ç‰‡çš„æ˜¾ç¤ºï¼Œè€Œ Coil ç”±äºä½¿ç”¨äº† Kotlin åç¨‹ï¼Œå¯ä»¥å¾ˆç®€æ´åœ°å®Œæˆå¼‚æ­¥åŠ è½½å’Œçº¿ç¨‹åˆ‡æ¢ï¼Œåœ¨æµç¨‹ä¸Š Coil ä¼šæ¸…æ™°å¾ˆå¤šã€‚ä½†å®é™…ä¸Š Coil ä¹Ÿæ˜¯å€Ÿé‰´äº†ä¸€äº›ä¼˜ç§€å¼€æºåº“çš„å®ç°æ€è·¯ï¼Œæ‰€ä»¥æˆ‘çœ‹ Coil çš„æºç çš„æ—¶å€™å°±æ€»ä¼šå‘ç°ä¸€äº› Glide å’Œ OkHttp çš„å½±å­ğŸ˜…ğŸ˜…

è¿™é‡Œå°±å…ˆæ¥å¯¹ Coil çš„å„ä¸ªç‰¹æ€§å’Œ Glide åšä¸‹ç®€å•çš„å¯¹æ¯”ï¼Œå…ˆè®©è¯»è€…æœ‰ä¸ªå¤§ä½“çš„å°è±¡

1. å®ç°è¯­è¨€
   - Glide å…¨ç›˜ä½¿ç”¨ Java è¯­è¨€æ¥å®ç°ï¼Œå¯¹äº Java å’Œ Kotlin è¯­è¨€çš„å‹å¥½ç¨‹åº¦å·®ä¸å¤š
   - Coil å…¨ç›˜ä½¿ç”¨ Kotlin è¯­è¨€æ¥å®ç°ï¼Œä¸º ImageView å£°æ˜äº†å¤šä¸ªç”¨äºåŠ è½½å›¾ç‰‡çš„æ‰©å±•å‡½æ•°ï¼Œå¯¹ Kotlin è¯­è¨€çš„å‹å¥½ç¨‹åº¦ä¼šæ›´é«˜å¾ˆå¤š
2. ç½‘ç»œè¯·æ±‚
   - Glide é»˜è®¤æ˜¯ä½¿ç”¨ HttpURLConnectionï¼Œä½†ä¹Ÿæä¾›äº†æ›´æ¢ç½‘ç»œè¯·æ±‚å®ç°é€”å¾„çš„å…¥å£
   - Coil é»˜è®¤æ˜¯ä½¿ç”¨ OkHttpï¼Œä½†ä¹Ÿæä¾›äº†æ›´æ¢ç½‘ç»œè¯·æ±‚å®ç°é€”å¾„çš„å…¥å£
3. ç”Ÿå‘½å‘¨æœŸç›‘å¬
   - Glide é€šè¿‡å‘ Activity æˆ–è€… Fragment æ³¨å…¥ä¸€ä¸ªæ—  UI ç•Œé¢çš„ Fragment æ¥å®ç°ç›‘å¬
   - Coil ç›´æ¥é€šè¿‡ Lifecycle æ¥å®ç°ç›‘å¬
4. å†…å­˜ç¼“å­˜
   - Glide çš„å†…å­˜ç¼“å­˜åˆ†ä¸º ActiveResources å’Œ MemoryCache ä¸¤çº§
   - Coil çš„å†…å­˜ç¼“å­˜åˆ†ä¸º WeakMemoryCache å’Œ StrongMemoryCache ä¸¤çº§ï¼Œæœ¬è´¨ä¸Šå’Œ Glide ä¸€æ ·
5. ç£ç›˜ç¼“å­˜
   - Glide åœ¨åŠ è½½åˆ°å›¾ç‰‡åé€šè¿‡ DiskLruCache æ¥è¿›è¡Œç£ç›˜ç¼“å­˜ï¼Œä¸”æä¾›äº†**æ˜¯å¦ç¼“å­˜ã€æ˜¯å¦ç¼“å­˜åŸå§‹å›¾ç‰‡ã€æ˜¯å¦ç¼“å­˜è½¬æ¢è¿‡åçš„å›¾ç‰‡**ç­‰å¤šä¸ªé€‰æ‹©
   - Coil é€šè¿‡ OkHttp çš„ç½‘ç»œè¯·æ±‚ç¼“å­˜æœºåˆ¶æ¥å®ç°ç£ç›˜ç¼“å­˜ï¼Œä¸”ç£ç›˜ç¼“å­˜åªå¯¹é€šè¿‡ç½‘ç»œè¯·æ±‚åŠ è½½åˆ°çš„åŸå§‹å›¾ç‰‡ç”Ÿæ•ˆï¼Œä¸ç¼“å­˜å…¶å®ƒæ¥æºçš„å›¾ç‰‡å’Œè½¬æ¢è¿‡åçš„å›¾ç‰‡
6. ç½‘ç»œç¼“å­˜
   - Glide ä¸å­˜åœ¨è¿™ä¸ªæ¦‚å¿µ
   - Coil ç›¸æ¯” Glide å¤šå‡ºäº†ä¸€å±‚ç½‘ç»œç¼“å­˜ï¼Œå¯ç”¨äºå®ç°**ä¸è¿›è¡Œç½‘ç»œåŠ è½½ï¼Œè€Œæ˜¯å¼ºåˆ¶ä½¿ç”¨æœ¬åœ°ç¼“å­˜**ï¼ˆå½“ç„¶ï¼Œå¦‚æœæœ¬åœ°ç¼“å­˜ä¸å­˜åœ¨çš„è¯å°±ä¼šæŠ¥é”™ï¼‰
7. çº¿ç¨‹æ¡†æ¶
   - Glide ä½¿ç”¨åŸç”Ÿçš„ ThreadPoolExecutor æ¥å®Œæˆåå°ä»»åŠ¡ï¼Œé€šè¿‡ Handler æ¥å®ç°çº¿ç¨‹åˆ‡æ¢
   - Coil ä½¿ç”¨ Coroutines æ¥å®Œæˆåå°ä»»åŠ¡åŠçº¿ç¨‹åˆ‡æ¢

> å…³äº Glide çš„æºç è§£æå¯ä»¥çœ‹æˆ‘çš„è¿™ä¸¤ç¯‡æ–‡ç« ï¼š
>
> - [ä¸‰æ–¹åº“æºç ç¬”è®°ï¼ˆ9ï¼‰-è¶…è¯¦ç»†çš„ Glide æºç è¯¦è§£](https://juejin.im/post/6891307560557608967)
> - [ä¸‰æ–¹åº“æºç ç¬”è®°ï¼ˆ10ï¼‰-Glide ä½ å¯èƒ½ä¸çŸ¥é“çš„çŸ¥è¯†ç‚¹](https://juejin.im/post/6892751013544263687)

æˆ‘çœ‹æºç æ—¶ä¹ æƒ¯ä»æœ€åŸºç¡€çš„ä½¿ç”¨æ–¹å¼æ¥å…¥æ‰‹ï¼Œåˆ†æå…¶æ•´ä¸ªè°ƒç”¨é“¾å…³ç³»å’Œä¼šæ¶‰åŠåˆ°çš„æ¨¡å—ï¼Œè¿™é‡Œä¹Ÿä¸ä¾‹å¤–ï¼Œå°±ä» Coil åŠ è½½ä¸€å¼ ç½‘ç»œå›¾ç‰‡æ¥å…¥æ‰‹

æœ€ç®€å•çš„åŠ è½½æ–¹å¼åªéœ€è¦è°ƒç”¨ä¸€ä¸ª`load`æ–¹æ³•å³å¯ï¼Œæ¯” Glide è¿˜ç®€æ´ï¼Œæƒ³è¦æ·»åŠ é…ç½®é¡¹çš„è¯å°±åœ¨ lambda å—ä¸­æ·»åŠ 

```kotlin
//ç›´æ¥åŠ è½½å›¾ç‰‡ï¼Œä¸æ·»åŠ ä»»ä½•é…ç½®é¡¹
imageView.load(imageUrl)

//åœ¨ lambda å—ä¸­æ·»åŠ é…ç½®é¡¹
imageView.load(imageUrl) {
    crossfade(true) //æ·¡å…¥æ·¡å‡º
    placeholder(android.R.drawable.presence_away) //å ä½å›¾
    error(android.R.drawable.stat_notify_error) //å›¾ç‰‡åŠ è½½å¤±è´¥æ—¶æ˜¾ç¤ºçš„å›¾
    transformations(
        CircleCropTransformation() //å°†å›¾ç‰‡æ˜¾ç¤ºä¸ºåœ†å½¢
    )
}
```

Coil ä¸º ImageView å£°æ˜äº†å¤šä¸ªç”¨äºåŠ è½½å›¾ç‰‡çš„æ‰©å±•å‡½æ•°ï¼Œå‡å‘½åä¸º `load`ï¼Œé»˜è®¤æƒ…å†µä¸‹æˆ‘ä»¬åªéœ€è¦ä¼ ä¸€ä¸ªå›¾ç‰‡æ¥æºåœ°å€å³å¯ï¼Œæ”¯æŒ **Stringã€HttpUrlã€Uriã€Fileã€Intã€Drawableã€Bitmap** ç­‰å¤šç§å…¥å‚ç±»å‹

```kotlin
/** @see ImageView.loadAny */
@JvmSynthetic
inline fun ImageView.load(
    uri: String?,
    imageLoader: ImageLoader = context.imageLoader,
    builder: ImageRequest.Builder.() -> Unit = {}
): Disposable = loadAny(uri, imageLoader, builder)
```

ä¸ç®¡ä¼ å…¥çš„æ˜¯ä»€ä¹ˆç±»å‹çš„å‚æ•°ï¼Œæœ€ç»ˆéƒ½ä¼šä¸­è½¬è°ƒç”¨åˆ° `loadAny` æ–¹æ³•ï¼Œé€šè¿‡ Builder æ¨¡å¼æ„å»ºå‡ºæœ¬æ¬¡çš„è¯·æ±‚å‚æ•° ImageRequestï¼Œç„¶åå°† ImageRequest æäº¤ç»™ ImageLoaderï¼Œç”±å…¶æ¥å®Œæˆå›¾ç‰‡çš„åŠ è½½ï¼Œæœ€ç»ˆè¿”å›ä¸€ä¸ª Disposable å¯¹è±¡

```kotlin
@JvmSynthetic
inline fun ImageView.loadAny(
    data: Any?,
    imageLoader: ImageLoader = context.imageLoader,
    builder: ImageRequest.Builder.() -> Unit = {}
): Disposable {
    val request = ImageRequest.Builder(context)
        .data(data)
        .target(this)
        .apply(builder)
        .build()
    return imageLoader.enqueue(request)
}
```

æ‰€ä»¥ï¼Œä¸€ä¸ªç®€å•çš„ `load` æ–¹æ³•å°±å·²ç»ä½¿ç”¨åˆ°äº†ä»¥ä¸‹å‡ ä¸ªç±»ï¼š

1. ImageRequestã€‚å›¾ç‰‡çš„è¯·æ±‚å‚æ•°
2. Disposableã€‚ç”¨äºå–æ¶ˆå›¾ç‰‡åŠ è½½æˆ–è€…ç­‰å¾…å›¾ç‰‡åŠ è½½å®Œæˆ
3. ImageLoaderã€‚å‘å…¶æäº¤ ImageRequest ï¼Œç”±å…¶å®Œæˆå›¾ç‰‡çš„åŠ è½½

ä¸‹é¢å°±æ¥åˆ†æä¸‹è¿™ä¸€æ•´ä¸ªæµç¨‹

# äº”ã€ImageRequest 

ImageRequest åŸºäº Builder æ¨¡å¼æ¥æ„å»ºï¼ŒåŒ…å«äº†åŠ è½½å›¾ç‰‡æ—¶çš„å„ä¸ªé…ç½®é¡¹ï¼Œå…¶é…ç½®é¡¹å¾ˆå¤šï¼Œé‡ç‚¹çœ‹å‰ä¹ä¸ª

```kotlin
private val context: Context //å¤–éƒ¨ä¼ å…¥çš„ Contextï¼Œä¾‹å¦‚ ImageView åŒ…å«çš„ Context
private var data: Any? //å›¾ç‰‡åœ°å€
private var target: Target? //å›¾ç‰‡åŠ è½½æˆåŠŸåçš„æ¥æ”¶ç±»
private var lifecycle: Lifecycle? //ImageView å…³è”çš„ç”Ÿå‘½å‘¨æœŸ
private var memoryCachePolicy: CachePolicy? //å†…å­˜ç¼“å­˜é…ç½®
private var diskCachePolicy: CachePolicy? //ç£ç›˜ç¼“å­˜é…ç½®
private var networkCachePolicy: CachePolicy? //ç½‘ç»œç¼“å­˜é…ç½®
private var fetcher: Pair<Fetcher<*>, Class<*>>? //å®Œæˆå›¾ç‰‡åŠ è½½çš„å¤„ç†å™¨
private var decoder: Decoder? //å®Œæˆå›¾ç‰‡è½¬ç çš„è½¬æ¢å™¨

private var defaults: DefaultRequestOptions
private var listener: Listener?
private var memoryCacheKey: MemoryCache.Key?
private var placeholderMemoryCacheKey: MemoryCache.Key?
private var colorSpace: ColorSpace? = null
private var transformations: List<Transformation>
private var headers: Headers.Builder?
private var parameters: Parameters.Builder?
private var sizeResolver: SizeResolver?
private var scale: Scale?
private var dispatcher: CoroutineDispatcher?
private var transition: Transition?
private var precision: Precision?
private var bitmapConfig: Bitmap.Config?
private var allowHardware: Boolean?
private var allowRgb565: Boolean?
@DrawableRes private var placeholderResId: Int?
private var placeholderDrawable: Drawable?
@DrawableRes private var errorResId: Int?
private var errorDrawable: Drawable?
@DrawableRes private var fallbackResId: Int?
private var fallbackDrawable: Drawable?
private var resolvedLifecycle: Lifecycle?
private var resolvedSizeResolver: SizeResolver?
private var resolvedScale: Scale?
```

## 1ã€Target

Target å³æœ€ç»ˆå›¾ç‰‡çš„æ¥æ”¶è½½ä½“ï¼ŒImageRequest æä¾›äº† `target` æ–¹æ³•ç”¨äºæŠŠ ImageView åŒ…è£…ä¸º Target ã€‚å¦‚æœæœ€ç»ˆå›¾ç‰‡çš„æ¥æ”¶è½½ä½“ä¸æ˜¯ ImageView çš„è¯ï¼Œå°±éœ€è¦å¼€å‘è€…è‡ªå·±æ¥å®ç° Target æ¥å£

```kotlin
fun target(imageView: ImageView) = target(ImageViewTarget(imageView))

fun target(target: Target?) = apply {
	this.target = target
	resetResolvedValues()
}
```

Target æ¥å£æä¾›äº†**å›¾ç‰‡å¼€å§‹åŠ è½½ã€å›¾ç‰‡åŠ è½½å¤±è´¥ã€å›¾ç‰‡åŠ è½½æˆåŠŸ**çš„äº‹ä»¶å›è°ƒï¼Œä¸»è¦æ˜¯ä¸ºäº†æ˜¾ç¤º**å ä½å›¾ã€é”™è¯¯å›¾ã€ç›®æ ‡å›¾**ç­‰å‡ ä¸ª

```kotlin
interface Target {
    /**
     * Called when the request starts.
     */
    @MainThread
    fun onStart(placeholder: Drawable?) {}

    /**
     * Called if an error occurs while executing the request.
     */
    @MainThread
    fun onError(error: Drawable?) {}

    /**
     * Called if the request completes successfully.
     */
    @MainThread
    fun onSuccess(result: Drawable) {}
}
```

ImageViewTarget å°±æ˜¯é€šè¿‡è°ƒç”¨ `setImageDrawable` æ¥æ˜¾å¼å„ä¸ªçŠ¶æ€çš„å›¾ç‰‡ï¼ŒåŒæ—¶ä¹Ÿå®ç°äº† DefaultLifecycleObserver æ¥å£ï¼Œæ„å‘³ç€ ImageViewTarget æœ¬èº«å°±**å…·å¤‡äº†ç›‘å¬ç”Ÿå‘½å‘¨æœŸäº‹ä»¶çš„èƒ½åŠ›**

```kotlin
/** A [Target] that handles setting images on an [ImageView]. */
open class ImageViewTarget(
    override val view: ImageView
) : PoolableViewTarget<ImageView>, TransitionTarget, DefaultLifecycleObserver {

    private var isStarted = false

    override val drawable: Drawable? get() = view.drawable

    override fun onStart(placeholder: Drawable?) = setDrawable(placeholder)

    override fun onError(error: Drawable?) = setDrawable(error)

    override fun onSuccess(result: Drawable) = setDrawable(result)
    
    /** Replace the [ImageView]'s current drawable with [drawable]. */
    protected open fun setDrawable(drawable: Drawable?) {
        (view.drawable as? Animatable)?.stop()
        view.setImageDrawable(drawable)
        updateAnimation()
    }

	Â·Â·Â·
}
```

## 2ã€Lifecycle

æ¯ä¸ª ImageRequest éƒ½ä¼šå…³è”ä¸€ä¸ª Context å¯¹è±¡ï¼Œå¦‚æœå¤–éƒ¨ä¼ å…¥çš„æ˜¯ ImageViewï¼Œåˆ™ä¼šå– ImageView å†…éƒ¨çš„ Contextã€‚Coil ä¼šåˆ¤æ–­ Context æ˜¯å¦å±äº LifecycleOwner ç±»å‹ï¼Œæ˜¯çš„è¯åˆ™å¯ä»¥æ‹¿åˆ°**å’Œ Activity æˆ–è€… Fragment å…³è”çš„ Lifecycle**ï¼Œå¦åˆ™æœ€ç»ˆå– **GlobalLifecycle**

å’Œ Activity æˆ–è€… Fragment å…³è”çš„ Lifecycle æ‰**å…·å¤‡æœ‰ç”Ÿå‘½å‘¨æœŸæ„ŸçŸ¥èƒ½åŠ›**ï¼Œè¿™æ · Coil æ‰å¯ä»¥åœ¨ Activity å¤„äºåå°æˆ–è€…å·²ç»é”€æ¯çš„æ—¶å€™æš‚åœä»»åŠ¡æˆ–è€…åœæ­¢ä»»åŠ¡ã€‚è€Œ GlobalLifecycle ä¼šé»˜è®¤ä¸”ä¸€ç›´å¤„äº RESUMED çŠ¶æ€ï¼Œè¿™æ ·ä»»åŠ¡å°±ä¼šä¸€ç›´è¿è¡Œç›´åˆ°æœ€ç»ˆç»“æŸï¼Œè¿™å¯èƒ½å¯¼è‡´å†…å­˜æ³„éœ²

```kotlin
private fun resolveLifecycle(): Lifecycle {
	val target = target
	val context = if (target is ViewTarget<*>) target.view.context else context
    //context å±äº LifecycleOwner ç±»å‹åˆ™è¿”å›å¯¹åº”çš„ Lifecycleï¼Œå¦åˆ™è¿”å› GlobalLifecycle
	return context.getLifecycle() ?: GlobalLifecycle
}

internal object GlobalLifecycle : Lifecycle() {

    private val owner = LifecycleOwner { this }

    override fun addObserver(observer: LifecycleObserver) {
        require(observer is DefaultLifecycleObserver) {
            "$observer must implement androidx.lifecycle.DefaultLifecycleObserver."
        }

        // Call the lifecycle methods in order and do not hold a reference to the observer.
        observer.onCreate(owner)
        observer.onStart(owner)
        observer.onResume(owner)
    }

    override fun removeObserver(observer: LifecycleObserver) {}

    override fun getCurrentState() = State.RESUMED

    override fun toString() = "coil.request.GlobalLifecycle"
}
```

## 3ã€CachePolicy

å’Œ Glide ä¸€æ ·ï¼ŒCoil ä¹Ÿå…·å¤‡äº†å¤šçº§ç¼“å­˜çš„èƒ½åŠ›ï¼Œå³**å†…å­˜ç¼“å­˜ memoryCachePolicyã€ç£ç›˜ç¼“å­˜ diskCachePolicyã€ç½‘ç»œç¼“å­˜ networkCachePolicy**ã€‚è¿™äº›ç¼“å­˜åŠŸèƒ½æ˜¯å¦å¼€å¯éƒ½æ˜¯é€šè¿‡ CachePolicy æ¥å®šä¹‰ï¼Œé»˜è®¤ä¸‰çº§ç¼“å­˜å…¨éƒ¨å¯è¯»å¯å†™

```kotlin
enum class CachePolicy(
    val readEnabled: Boolean,
    val writeEnabled: Boolean
) {
    ENABLED(true, true), //å¯è¯»å¯å†™
    READ_ONLY(true, false), //åªè¯»
    WRITE_ONLY(false, true), //åªå†™
    DISABLED(false, false) //ä¸å¯è¯»ä¸å¯å†™ï¼Œå³ç¦ç”¨
}
```

## 4ã€Fetcher

Fetcher æ˜¯**æ ¹æ®å›¾ç‰‡æ¥æºåœ°å€è½¬æ¢ä¸ºç›®æ ‡æ•°æ®ç±»å‹**çš„è½¬æ¢å™¨ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬ä¼ å…¥äº† Int ç±»å‹çš„ drawableResIdï¼Œæƒ³è¦ä»¥æ­¤æ‹¿åˆ° Drawableï¼Œé‚£ä¹ˆè¿™é‡Œçš„ `Class<*>` å³ `Class<Int>` ï¼Œ`Fetcher<*>` å³ `Fetcher<Drawable>`

```kotlin
/** @see Builder.fetcher */
val fetcher: Pair<Fetcher<*>, Class<*>>?,
```

Fetcher æ¥å£åŒ…å«ä¸‰ä¸ªæ–¹æ³•

```kotlin
interface Fetcher<T : Any> {

    /**
     * å¦‚æœèƒ½å¤„ç† data åˆ™è¿”å› true
     */
    fun handles(data: T): Boolean = true

    /**
     * æ ¹æ® data æ¥è®¡ç®—ç”¨äºå†…å­˜ç¼“å­˜æ—¶çš„å”¯ä¸€ key
     * å…·æœ‰ç›¸åŒ key çš„ç¼“å­˜å°†è¢« MemoryCache è§†ä¸ºç›¸åŒçš„æ•°æ®
     * å¦‚æœè¿”å› null åˆ™ä¸ä¼šå°† fetch åçš„æ•°æ®ç¼“å­˜åˆ°å†…å­˜ä¸­
     */
    fun key(data: T): String?

    /**
     * æ ¹æ® data å°†ç›®æ ‡å›¾ç‰‡åŠ è½½åˆ°å†…å­˜ä¸­
     */
    suspend fun fetch(
        pool: BitmapPool,
        data: T,
        size: Size,
        options: Options
    ): FetchResult
}
```

Coil é»˜è®¤æä¾›äº†ä»¥ä¸‹å…«ç§ç±»å‹çš„ Fetcherï¼Œåˆ†åˆ«ç”¨äºå¤„ç† **HttpUriUriã€HttpUriUrlã€Fileã€Assetã€ContentUriã€Resourceã€Drawableã€Bitmap** ç­‰ç±»å‹çš„å›¾ç‰‡æ¥æºåœ°å€

```kotlin
private val registry = componentRegistry.newBuilder()
    Â·Â·Â·
    // Fetchers
    .add(HttpUriFetcher(callFactory))
    .add(HttpUrlFetcher(callFactory))
    .add(FileFetcher(addLastModifiedToFileCacheKey))
    .add(AssetUriFetcher(context))
    .add(ContentUriFetcher(context))
    .add(ResourceUriFetcher(context, drawableDecoder))
    .add(DrawableFetcher(drawableDecoder))
    .add(BitmapFetcher())
    Â·Â·Â·
    .build()
```

## 5ã€Decoder

Decoder æ¥å£ç”¨äºæä¾›å°† BufferedSource è½¬ç ä¸º Drawable çš„èƒ½åŠ›ï¼ŒBufferedSource å°±å¯¹åº”ç€ä¸åŒç±»å‹çš„å›¾ç‰‡èµ„æº

Coil æä¾›äº†ä»¥ä¸‹å‡ ä¸ª Decoder å®ç°ç±»

- BitmapFactoryDecoderã€‚ç”¨äºå®ç° Bitmap è½¬ç 
- GifDecoderã€ImageDecoderDecoderã€‚ç”¨äºå®ç° Gifã€Animated WebPsã€Animated HEIFs è½¬ç 
- SvgDecoderã€‚ç”¨äºå®ç° Svg è½¬ç 

```kotlin
interface Decoder {
    //å¦‚æœæ­¤ Decoder èƒ½å¤Ÿå¤„ç† source åˆ™è¿”å› true
    fun handles(source: BufferedSource, mimeType: String?): Boolean
    
    //ç”¨äºå°† source è§£ç ä¸º Drawable
    suspend fun decode(
        pool: BitmapPool,
        source: BufferedSource,
        size: Size,
        options: Options
    ): DecodeResult
}
```

# å…­ã€Disposable

Disposable æ˜¯æˆ‘ä»¬è°ƒç”¨ `load` æ–¹æ³•åçš„è¿”å›å€¼ï¼Œä¸ºå¤–éƒ¨æä¾›ç”¨äº**å–æ¶ˆå›¾ç‰‡åŠ è½½**æˆ–è€…**ç­‰å¾…å›¾ç‰‡åŠ è½½å®Œæˆ**çš„æ–¹æ³•

```kotlin
interface Disposable {
    //å¦‚æœä»»åŠ¡å·²ç»å®Œæˆæˆ–è€…å–æ¶ˆçš„è¯ï¼Œåˆ™è¿”å› true
    val isDisposed: Boolean
    
    //å–æ¶ˆæ­£åœ¨è¿›è¡Œçš„ä»»åŠ¡å¹¶é‡Šæ”¾ä¸æ­¤ä»»åŠ¡å…³è”çš„æ‰€æœ‰èµ„æº
    fun dispose()
    
    //éé˜»å¡å¼åœ°ç­‰å¾…ä»»åŠ¡ç»“æŸ
    @ExperimentalCoilApi
    suspend fun await()
}
```

ç”±äº Coil æ˜¯ä½¿ç”¨åç¨‹æ¥åŠ è½½å›¾ç‰‡ï¼Œæ‰€ä»¥æ¯ä¸ªä»»åŠ¡éƒ½ä¼šå¯¹åº”ä¸€ä¸ª Job

å¦‚æœ ImageRequest åŒ…å«çš„ Target å¯¹åº”ç€æŸä¸ª Viewï¼ˆå³å±äº ViewTarget ç±»å‹ï¼‰ï¼Œé‚£ä¹ˆè¿”å›çš„ Disposable å³ ViewTargetDisposableã€‚è€Œ View å¯èƒ½éœ€è¦å…ˆåè¯·æ±‚å¤šå¼ å›¾ç‰‡ï¼ˆä¾‹å¦‚ RecyclerView çš„æ¯ä¸ª Item éƒ½æ˜¯ ImageViewï¼‰ï¼Œé‚£ä¹ˆå½“å¯åŠ¨æ–°ä»»åŠ¡åæ—§ä»»åŠ¡å°±åº”è¯¥è¢«å–æ¶ˆï¼Œæ‰€ä»¥ ViewTargetDisposable å°±åŒ…å«äº†ä¸€ä¸ª UUID æ¥å”¯ä¸€æ ‡è¯†æ¯ä¸ªè¯·æ±‚ã€‚å…¶å®ƒæƒ…å†µå°±éƒ½æ˜¯è¿”å› BaseTargetDisposable

```kotlin
internal class BaseTargetDisposable(private val job: Job) : Disposable {

    override val isDisposed
        get() = !job.isActive

    override fun dispose() {
        if (isDisposed) return
        job.cancel()
    }

    @ExperimentalCoilApi
    override suspend fun await() {
        if (isDisposed) return
        job.join()
    }
}

internal class ViewTargetDisposable(
    private val requestId: UUID,
    private val target: ViewTarget<*>
) : Disposable {

    override val isDisposed
        get() = target.view.requestManager.currentRequestId != requestId

    override fun dispose() {
        if (isDisposed) return
        target.view.requestManager.clearCurrentRequest()
    }

    @ExperimentalCoilApi
    override suspend fun await() {
        if (isDisposed) return
        target.view.requestManager.currentRequestJob?.join()
    }
}
```

# ä¸ƒã€ImageLoader

ä¸Šé¢æœ‰è¯´è¿‡ï¼Œ`loadAny`æ–¹æ³•æœ€ç»ˆæ˜¯ä¼šé€šè¿‡è°ƒç”¨ `imageLoader.enqueue(request)`æ¥å‘èµ·ä¸€ä¸ªå›¾ç‰‡åŠ è½½è¯·æ±‚çš„ï¼Œé‚£ä¹ˆé‡ç‚¹å°±æ˜¯è¦æ¥çœ‹ ImageLoader æ˜¯å¦‚ä½•å®ç°çš„

```kotlin
@JvmSynthetic
inline fun ImageView.loadAny(
    data: Any?,
    imageLoader: ImageLoader = context.imageLoader,
    builder: ImageRequest.Builder.() -> Unit = {}
): Disposable {
    val request = ImageRequest.Builder(context)
        .data(data)
        .target(this)
        .apply(builder)
        .build()
    return imageLoader.enqueue(request)
}
```

ImageLoader æ˜¯ä¸€ä¸ªæ¥å£ï¼Œæ˜¯æ‰¿è½½äº†æ‰€æœ‰å›¾ç‰‡åŠ è½½ä»»åŠ¡å’Œå®ç°ç¼“å­˜å¤ç”¨çš„åŠ è½½å™¨

```kotlin
interface ImageLoader {
    //ç”¨äºæä¾› ImageRequest çš„é»˜è®¤é…ç½®é¡¹
    val defaults: DefaultRequestOptions
    //å†…å­˜ç¼“å­˜
    val memoryCache: MemoryCache
	//Bitmapç¼“å­˜æ± 
    val bitmapPool: BitmapPool
	//å¼‚æ­¥åŠ è½½å›¾ç‰‡
    fun enqueue(request: ImageRequest): Disposable
	//åŒæ­¥åŠ è½½å›¾ç‰‡
    suspend fun execute(request: ImageRequest): ImageResult
	//åœæ­¢å…¨éƒ¨ä»»åŠ¡
    fun shutdown()
}
```

ImageLoader çš„å”¯ä¸€å®ç°ç±»æ˜¯ RealImageLoaderï¼Œå…¶`enqueue`æ–¹æ³•ä¼šå¯åŠ¨ä¸€ä¸ªåç¨‹ï¼Œåœ¨ job é‡Œæ‰§è¡Œ `executeMain` æ–¹æ³•å¾—åˆ° ImageResultï¼ŒImageResult å°±åŒ…å«äº†æœ€ç»ˆå¾—åˆ°çš„å›¾ç‰‡ã€‚åŒæ—¶ï¼Œjob ä¼šè¢«åŒ…å«åœ¨è¿”å›çš„ Disposable å¯¹è±¡é‡Œï¼Œè¿™æ ·å¤–éƒ¨æ‰èƒ½**å–æ¶ˆå›¾ç‰‡åŠ è½½**æˆ–è€…**ç­‰å¾…å›¾ç‰‡åŠ è½½å®Œæˆ**

```kotlin
override fun enqueue(request: ImageRequest): Disposable {
    // Start executing the request on the main thread.
    val job = scope.launch {
        val result = executeMain(request, REQUEST_TYPE_ENQUEUE)
        if (result is ErrorResult) throw result.throwable
    }

    // Update the current request attached to the view and return a new disposable.
    return if (request.target is ViewTarget<*>) {
        val requestId = request.target.view.requestManager.setCurrentRequestJob(job)
        ViewTargetDisposable(requestId, request.target)
    } else {
        BaseTargetDisposable(job)
    }
}
```

executeMain æ–¹æ³•çš„é€»è¾‘ä¹Ÿæ¯”è¾ƒç®€å•ï¼Œå¯ä»¥æ¦‚æ‹¬ä¸ºï¼š

1. ä¸º target å’Œ request åˆ›å»ºä¸€ä¸ªä»£ç†ç±»ï¼Œç”¨äºæ”¯æŒ Bitmap ç¼“å­˜å’Œ Lifecycle ç›‘å¬
2. å¦‚æœå¤–éƒ¨å‘èµ·çš„æ˜¯å¼‚æ­¥è¯·æ±‚çš„è¯ï¼ˆå³ REQUEST_TYPE_ENQUEUEï¼‰ï¼Œé‚£ä¹ˆå°±éœ€è¦ç­‰åˆ° Lifecycle è‡³å°‘å¤„äº Started çŠ¶æ€ä¹‹åæ‰èƒ½ç»§ç»­æ‰§è¡Œï¼Œè¿™æ ·å½“ Activity è¿˜å¤„äºåå°æ—¶å°±ä¸ä¼šå‘èµ·è¯·æ±‚äº†
3. è·å–å ä½å›¾å¹¶ä¼ ç»™ target 
4. è·å– target éœ€è¦çš„å›¾ç‰‡å°ºå¯¸å¤§å°ï¼Œä»¥ä¾¿æŒ‰éœ€åŠ è½½ï¼Œå¯¹äº ImageViewTarget æ¥è¯´ï¼Œå³è·å– ImageView çš„å®½é«˜å±æ€§
5. è°ƒç”¨ executeChain æ–¹æ³•æ‹¿åˆ° ImageResultï¼Œåˆ¤æ–­æ˜¯å¦æˆåŠŸï¼Œè°ƒç”¨ target å¯¹åº”çš„æˆåŠŸæˆ–è€…å¤±è´¥çš„æ–¹æ³•

```kotlin
@MainThread
private suspend fun executeMain(initialRequest: ImageRequest, type: Int): ImageResult {
    Â·Â·Â·

    // Apply this image loader's defaults to this request.
    val request = initialRequest.newBuilder().defaults(defaults).build()

    //target ä»£ç†ï¼Œç”¨äºæ”¯æŒBitmapæ± 
    val targetDelegate = delegateService.createTargetDelegate(request.target, type, eventListener)

    //request ä»£ç†ï¼Œç”¨äºæ”¯æŒ lifecycle
    val requestDelegate = delegateService.createRequestDelegate(request, targetDelegate, coroutineContext.job)

    try {
        //å¦‚æœ data ä¸º nullï¼Œé‚£ä¹ˆå°±æŠ›å‡ºå¼‚å¸¸
        if (request.data == NullRequestData) throw NullRequestDataException()

        //å¦‚æœæ˜¯å¼‚æ­¥è¯·æ±‚çš„è¯ï¼Œé‚£ä¹ˆå°±éœ€è¦ç­‰åˆ° Lifecycle è‡³å°‘å¤„äº Started çŠ¶æ€ä¹‹åæ‰èƒ½ç»§ç»­æ‰§è¡Œ
        if (type == REQUEST_TYPE_ENQUEUE) request.lifecycle.awaitStarted()

        //è·å–å±•ä½å›¾ä¼ ç»™ targetï¼Œä»å†…å­˜ç¼“å­˜ä¸­åŠ è½½æˆ–è€…ä»å…¨æ–°åŠ è½½
        val cached = memoryCacheService[request.placeholderMemoryCacheKey]?.bitmap
        try {
            targetDelegate.metadata = null
            targetDelegate.start(cached?.toDrawable(request.context) ?: request.placeholder, cached)
            eventListener.onStart(request)
            request.listener?.onStart(request)
        } finally {
            referenceCounter.decrement(cached)
        }

        //è·å– target éœ€è¦çš„å›¾ç‰‡å°ºå¯¸å¤§å°ï¼ŒæŒ‰éœ€åŠ è½½
        eventListener.resolveSizeStart(request)
        val size = request.sizeResolver.size()
        eventListener.resolveSizeEnd(request, size)

        // Execute the interceptor chain.
        val result = executeChain(request, type, size, cached, eventListener)

        // Set the result on the target.
        //åˆ¤æ–­ result æˆåŠŸä¸å¦ï¼Œè°ƒç”¨ç›¸åº”çš„æ–¹æ³•
        when (result) {
            is SuccessResult -> onSuccess(result, targetDelegate, eventListener)
            is ErrorResult -> onError(result, targetDelegate, eventListener)
        }
        return result
    } catch (throwable: Throwable) {
        if (throwable is CancellationException) {
            onCancel(request, eventListener)
            throw throwable
        } else {
            // Create the default error result if there's an uncaught exception.
            val result = requestService.errorResult(request, throwable)
            onError(result, targetDelegate, eventListener)
            return result
        }
    } finally {
        requestDelegate.complete()
    }
}
```

`executeChain`æ–¹æ³•å°±æ¯”è¾ƒæœ‰æ„æ€äº†ï¼Œæœ‰çœ‹è¿‡ OkHttp æºç çš„åŒå­¦åº”è¯¥ä¼šå¯¹ RealInterceptorChain æœ‰ç‚¹å°è±¡ï¼ŒOkHttp çš„æ‹¦æˆªå™¨å°±æ˜¯é€šè¿‡è¯¥åŒåç±»æ¥å®ç°çš„ï¼Œå¾ˆæ˜¾ç„¶ Coil å€Ÿé‰´äº† OkHttp çš„å®ç°æ€è·¯ï¼Œæå¤§æ–¹ä¾¿äº†åç»­åŠŸèƒ½æ‰©å±•ï¼Œä¹Ÿç»™äº†å¤–éƒ¨æ§åˆ¶æ•´ä¸ªå›¾ç‰‡åŠ è½½æµç¨‹çš„å…¥å£ï¼Œå¯æ‰©å±•æ€§ +100

> ä¸äº†è§£ OkHttp çš„ RealInterceptorChain å®ç°æ€è·¯çš„å¯ä»¥çœ‹æˆ‘çš„è¿™ç¯‡æ–‡ç« ï¼Œè¿™é‡Œä¸å†èµ˜è¿°ï¼š[ä¸‰æ–¹åº“æºç ç¬”è®°ï¼ˆ11ï¼‰-OkHttp æºç è¯¦è§£](https://juejin.cn/post/6895369745445748749)

```kotlin
private val interceptors = registry.interceptors + EngineInterceptor(registry, bitmapPool, referenceCounter,
    strongMemoryCache, memoryCacheService, requestService, systemCallbacks, drawableDecoder, logger)

private suspend inline fun executeChain(
    request: ImageRequest,
    type: Int,
    size: Size,
    cached: Bitmap?,
    eventListener: EventListener
): ImageResult {
    val chain = RealInterceptorChain(request, type, interceptors, 0, request, size, cached, eventListener)
    return if (launchInterceptorChainOnMainThread) {
        chain.proceed(request)
    } else {
        withContext(request.dispatcher) {
            chain.proceed(request)
        }
    }
}
```

æ‰€ä»¥è¯´ï¼Œé‡ç‚¹å°±è¿˜æ˜¯è¦æ¥çœ‹ EngineInterceptor çš„ `intercept` æ–¹æ³•ï¼Œå…¶é€»è¾‘å¯ä»¥æ¦‚æ‹¬ä¸ºï¼š

1. æ‰¾åˆ°èƒ½å¤„ç†æœ¬æ¬¡è¯·æ±‚çš„ fetcherï¼Œæ‰§è¡Œä¸‹ä¸€æ­¥
2. è®¡ç®—æœ¬æ¬¡è¦åŠ è½½çš„å›¾ç‰‡åœ¨å†…å­˜ä¸­çš„ç¼“å­˜ keyï¼Œå¦‚æœå†…å­˜ç¼“å­˜å¯ç”¨çš„è¯å°±ç›´æ¥ä½¿ç”¨ç¼“å­˜ï¼Œç»“æŸæµç¨‹
3. å¦‚æœå­˜åœ¨å†…å­˜ç¼“å­˜ä½†æ˜¯ä¸å¯ç”¨ï¼ˆå¯èƒ½æ˜¯ç”±äºç¡¬ä»¶åŠ é€Ÿé…ç½®ä¸ç¬¦æˆ–è€…æ˜¯æœ¬æ¬¡ä¸å…è®¸ä½¿ç”¨ç¼“å­˜ï¼‰ï¼Œé‚£ä¹ˆå°±æ›´æ–°è¯¥ç¼“å­˜åœ¨å†…å­˜ä¸­çš„å¯ç”¨çŠ¶æ€å¹¶æ›´æ–°å¼•ç”¨è®¡æ•°ï¼Œæ‰§è¡Œä¸‹ä¸€æ­¥
4. è°ƒç”¨ execute æ–¹æ³•å®Œæˆå›¾ç‰‡åŠ è½½ï¼Œå¾—åˆ° drawableï¼Œç»“æŸæµç¨‹

`execute` æ–¹æ³•çš„é€»è¾‘å¯ä»¥æ¦‚æ‹¬ä¸ºï¼š

1. é€šè¿‡ fetcher æ¥æ‰§è¡Œç£ç›˜åŠ è½½æˆ–è€…ç½‘ç»œè¯·æ±‚ï¼Œå¾—åˆ° fetchResultï¼Œæ‰§è¡Œä¸‹ä¸€æ­¥
2. å¦‚æœ fetchResult å±äº DrawableResult çš„è¯ï¼Œé‚£ä¹ˆå°±å·²ç»æ‹¿åˆ°ç›®æ ‡å›¾ç‰‡ç±»å‹ Drawable äº†ï¼Œé‚£ä¹ˆç›´æ¥è¿”å›ï¼Œç»“æŸæµç¨‹
3. å¦‚æœ fetchResult å±äº SourceResult ç±»å‹ï¼Œå³æ‹¿åˆ°çš„æ•°æ®ç±»å‹æ˜¯ BufferedSourceï¼Œæ­¤æ—¶è¿˜éœ€è¦è½¬ç ä¸º Drawableï¼Œæ‰§è¡Œä¸‹ä¸€æ­¥
4. å…ˆåˆ¤æ–­æœ¬æ¬¡è¯·æ±‚æ˜¯å¦å±äº**é¢„åŠ è½½**ï¼Œå³å¯èƒ½å¤–éƒ¨ç°åœ¨ä¸éœ€è¦ä½¿ç”¨åˆ°è¯¥å›¾ç‰‡ï¼Œåªæ˜¯æƒ³å…ˆå°†å›¾ç‰‡ç¼“å­˜åˆ°æœ¬åœ°ç£ç›˜ï¼Œæ–¹ä¾¿åç»­èƒ½å¤Ÿå¿«é€ŸåŠ è½½ã€‚é¢„åŠ è½½çš„åˆ¤æ–­æ ‡å‡†å°±æ˜¯ï¼š**å¼‚æ­¥è¯·æ±‚ + target ä¸ºnull + ä¸å…è®¸ç¼“å­˜åˆ°å†…å­˜ä¸­**ã€‚å±äºé¢„åŠ è½½çš„è¯å°±ä¸éœ€è¦å°†åŠ è½½åˆ°çš„å›¾ç‰‡è¿›è¡Œè½¬ç äº†ï¼Œæ­¤æ—¶å°±ä½¿ç”¨ EmptyDecoderï¼Œå¦åˆ™å°±è¿˜æ˜¯éœ€è¦å»æ‰¾èƒ½è¿›è¡Œå®é™…è½¬ç çš„ Decoderã€‚æ‹¿åˆ° Decoder åå°±æ‰§è¡Œä¸‹ä¸€æ­¥
5. é€šè¿‡ Decoder å®Œæˆå›¾ç‰‡è½¬ç ï¼Œå¾—åˆ° Drawableï¼Œç»“æŸæµç¨‹

```kotlin
/** The last interceptor in the chain which executes the [ImageRequest]. */
internal class EngineInterceptor(
    private val registry: ComponentRegistry,
    private val bitmapPool: BitmapPool,
    private val referenceCounter: BitmapReferenceCounter,
    private val strongMemoryCache: StrongMemoryCache,
    private val memoryCacheService: MemoryCacheService,
    private val requestService: RequestService,
    private val systemCallbacks: SystemCallbacks,
    private val drawableDecoder: DrawableDecoderService,
    private val logger: Logger?
) : Interceptor {

    override suspend fun intercept(chain: Interceptor.Chain): ImageResult {
        try {
            // This interceptor uses some internal APIs.
            check(chain is RealInterceptorChain)

            val request = chain.request
            val context = request.context
            val data = request.data
            val size = chain.size
            val eventListener = chain.eventListener

            // Perform any data mapping.
            eventListener.mapStart(request, data)
            val mappedData = registry.mapData(data)
            eventListener.mapEnd(request, mappedData)

            //æ‰¾åˆ°èƒ½å¤„ç†æœ¬æ¬¡è¯·æ±‚çš„ fetcher
            val fetcher = request.fetcher(mappedData) ?: registry.requireFetcher(mappedData)
            //è®¡ç®—æœ¬æ¬¡è¦åŠ è½½çš„å›¾ç‰‡åœ¨å†…å­˜ä¸­çš„ç¼“å­˜ key
            val memoryCacheKey = request.memoryCacheKey ?: computeMemoryCacheKey(request, mappedData, fetcher, size)
            //å¦‚æœæœ¬æ¬¡å…è®¸ä½¿ç”¨å†…å­˜ç¼“å­˜çš„è¯ï¼Œé‚£ä¹ˆå°±å°è¯•ä» memoryCacheService ä¸­è·å–ç¼“å­˜
            val value = if (request.memoryCachePolicy.readEnabled) memoryCacheService[memoryCacheKey] else null

            // Ignore the cached bitmap if it is hardware-backed and the request disallows hardware bitmaps.
            val cachedDrawable = value?.bitmap
                ?.takeIf { requestService.isConfigValidForHardware(request, it.safeConfig) }
                ?.toDrawable(context)

            //å¦‚æœç¼“å­˜å¯ç”¨ï¼Œåˆ™ç›´æ¥è¿”å›ç¼“å­˜
            if (cachedDrawable != null && isCachedValueValid(memoryCacheKey, value, request, size)) {
                return SuccessResult(
                    drawable = value.bitmap.toDrawable(context),
                    request = request,
                    metadata = Metadata(
                        memoryCacheKey = memoryCacheKey,
                        isSampled = value.isSampled,
                        dataSource = DataSource.MEMORY_CACHE,
                        isPlaceholderMemoryCacheKeyPresent = chain.cached != null
                    )
                )
            }

            // Fetch, decode, transform, and cache the image on a background dispatcher.
            return withContext(request.dispatcher) {
                //å¦‚æœ request.data å±äº BitmapDrawable æˆ–è€… Bitmap ç±»å‹
                //ä¼šæ‰§è¡Œåˆ°è¿™é‡Œè¯´æ˜ data ä¸ç¬¦åˆæœ¬æ¬¡çš„ä½¿ç”¨æ¡ä»¶ï¼Œé‚£ä¹ˆå°±åœ¨å†…å­˜ä¸­å°†å…¶æ ‡è®°ä¸ºä¸å¯ç”¨çŠ¶æ€
                invalidateData(request.data)

                //å­˜åœ¨ç¼“å­˜ä½†æ˜¯æ²¡ç”¨ä¸Šï¼Œå¼•ç”¨è®¡æ•°å‡ä¸€
                if (value != null) referenceCounter.decrement(value.bitmap)

                // Fetch and decode the image.
                val (drawable, isSampled, dataSource) =
                    execute(mappedData, fetcher, request, chain.requestType, size, eventListener)

                // Mark the drawable's bitmap as eligible for pooling.
                validateDrawable(drawable)
                
                //å°è¯•å°†è·å–åˆ°çš„ bitmap ç¼“å­˜åˆ°å†…å­˜ä¸­
                val isCached = writeToMemoryCache(request, memoryCacheKey, drawable, isSampled)

                // Return the result.
                SuccessResult(
                    drawable = drawable,
                    request = request,
                    metadata = Metadata(
                        memoryCacheKey = memoryCacheKey.takeIf { isCached },
                        isSampled = isSampled,
                        dataSource = dataSource,
                        isPlaceholderMemoryCacheKeyPresent = chain.cached != null
                    )
                )
            }
        } catch (throwable: Throwable) {
            if (throwable is CancellationException) {
                throw throwable
            } else {
                return requestService.errorResult(chain.request, throwable)
            }
        }
    }
    
    /** Load the [data] as a [Drawable]. Apply any [Transformation]s. */
    private suspend inline fun execute(
        data: Any,
        fetcher: Fetcher<Any>,
        request: ImageRequest,
        type: Int,
        size: Size,
        eventListener: EventListener
    ): DrawableResult {
        val options = requestService.options(request, size, systemCallbacks.isOnline)

        eventListener.fetchStart(request, fetcher, options)
        val fetchResult = fetcher.fetch(bitmapPool, data, size, options)
        eventListener.fetchEnd(request, fetcher, options, fetchResult)

        val baseResult = when (fetchResult) {
            is SourceResult -> {
                val decodeResult = try {
                    // Check if we're cancelled.
                    coroutineContext.ensureActive()

                    //åˆ¤æ–­æœ¬æ¬¡è¯·æ±‚æ˜¯å¦å±äºé¢„åŠ è½½ï¼Œå³å¯èƒ½å¤–éƒ¨åªæ˜¯æƒ³å…ˆå°†å›¾ç‰‡åŠ è½½åˆ°æœ¬åœ°ç£ç›˜ï¼Œæ–¹ä¾¿åç»­ä½¿ç”¨
                    //é¢„åŠ è½½çš„åˆ¤æ–­æ ‡å‡†å°±æ˜¯ï¼šå¼‚æ­¥è¯·æ±‚ + targetä¸ºnull + ä¸ç¼“å­˜åˆ°å†…å­˜ä¸­
                    //å±äºé¢„åŠ è½½çš„è¯å°±ä¸éœ€è¦å°†åŠ è½½åˆ°çš„å›¾ç‰‡è¿›è¡Œè½¬ç äº†ï¼Œå°±ä¼šä½¿ç”¨ EmptyDecoder
                    //å¦åˆ™å°±è¿˜æ˜¯éœ€è¦å»æ‰¾èƒ½è¿›è¡Œè½¬ç çš„ Decoder
                    val isDiskOnlyPreload = type == REQUEST_TYPE_ENQUEUE &&
                        request.target == null &&
                        !request.memoryCachePolicy.writeEnabled
                    val decoder = if (isDiskOnlyPreload) {
                        // Skip decoding the result if we are preloading the data and writing to the memory cache is
                        // disabled. Instead, we exhaust the source and return an empty result.
                        EmptyDecoder
                    } else {
                        request.decoder ?: registry.requireDecoder(request.data, fetchResult.source, fetchResult.mimeType)
                    }

                    // Decode the stream.
                    eventListener.decodeStart(request, decoder, options)
                    //è¿›è¡Œè½¬ç ï¼Œå¾—åˆ°ç›®æ ‡ç±»å‹ Drawable
                    val decodeResult = decoder.decode(bitmapPool, fetchResult.source, size, options)
                    eventListener.decodeEnd(request, decoder, options, decodeResult)
                    decodeResult
                } catch (throwable: Throwable) {
                    // Only close the stream automatically if there is an uncaught exception.
                    // This allows custom decoders to continue to read the source after returning a drawable.
                    fetchResult.source.closeQuietly()
                    throw throwable
                }

                // Combine the fetch and decode operations' results.
                DrawableResult(
                    drawable = decodeResult.drawable,
                    isSampled = decodeResult.isSampled,
                    dataSource = fetchResult.dataSource
                )
            }
            is DrawableResult -> fetchResult
        }

        // Check if we're cancelled.
        coroutineContext.ensureActive()

        // Apply any transformations and prepare to draw.
        val finalResult = applyTransformations(baseResult, request, size, options, eventListener)
        (finalResult.drawable as? BitmapDrawable)?.bitmap?.prepareToDraw()
        return finalResult
    }
    
}
```

Fetcher æ˜¯**æ ¹æ®å›¾ç‰‡æ¥æºåœ°å€è½¬æ¢ä¸ºç›®æ ‡æ•°æ®ç±»å‹**çš„è½¬æ¢å™¨ã€‚Coil é»˜è®¤æä¾›äº†ä»¥ä¸‹å…«ç§ç±»å‹çš„ Fetcherï¼Œåˆ†åˆ«ç”¨äºå¤„ç† **HttpUriã€HttpUrlã€Fileã€Assetã€ContentUriã€Resourceã€Drawableã€Bitmap** ç­‰ç±»å‹çš„å›¾ç‰‡æ¥æºåœ°å€

```kotlin
private val registry = componentRegistry.newBuilder()
    Â·Â·Â·
    // Fetchers
    .add(HttpUriFetcher(callFactory))
    .add(HttpUrlFetcher(callFactory))
    .add(FileFetcher(addLastModifiedToFileCacheKey))
    .add(AssetUriFetcher(context))
    .add(ContentUriFetcher(context))
    .add(ResourceUriFetcher(context, drawableDecoder))
    .add(DrawableFetcher(drawableDecoder))
    .add(BitmapFetcher())
    Â·Â·Â·
    .build()
```

æ‰€ä»¥ï¼Œå¦‚æœæˆ‘ä»¬å¤–éƒ¨è¦åŠ è½½çš„æ˜¯ä¸€å¼ ç½‘ç»œå›¾ç‰‡ï¼Œä¸”ä¼ å…¥çš„æ˜¯ String ç±»å‹çš„ ImageUrlï¼Œé‚£ä¹ˆæœ€ç»ˆå¯¹åº”ä¸Šçš„å°±æ˜¯ HttpUriFetcherï¼Œå…¶çˆ¶ç±» HttpFetcher å°±ä¼šé€šè¿‡ OkHttp æ¥è¿›è¡Œç½‘ç»œè¯·æ±‚äº†ã€‚è‡³æ­¤ï¼Œæ•´ä¸ªå›¾ç‰‡åŠ è½½æµç¨‹å°±ç»“æŸäº†

```kotlin
internal class HttpUriFetcher(callFactory: Call.Factory) : HttpFetcher<Uri>(callFactory) {

    override fun handles(data: Uri) = data.scheme == "http" || data.scheme == "https"

    override fun key(data: Uri) = data.toString()

    override fun Uri.toHttpUrl(): HttpUrl = HttpUrl.get(toString())
}

internal abstract class HttpFetcher<T : Any>(private val callFactory: Call.Factory) : Fetcher<T> {

    /**
     * Perform this conversion in a [Fetcher] instead of a [Mapper] so
     * [HttpUriFetcher] can execute [HttpUrl.get] on a background thread.
     */
    abstract fun T.toHttpUrl(): HttpUrl

    override suspend fun fetch(
        pool: BitmapPool,
        data: T,
        size: Size,
        options: Options
    ): FetchResult {
        val url = data.toHttpUrl()
        val request = Request.Builder().url(url).headers(options.headers)

        val networkRead = options.networkCachePolicy.readEnabled
        val diskRead = options.diskCachePolicy.readEnabled
        when {
            !networkRead && diskRead -> {
                request.cacheControl(CacheControl.FORCE_CACHE)
            }
            networkRead && !diskRead -> if (options.diskCachePolicy.writeEnabled) {
                request.cacheControl(CacheControl.FORCE_NETWORK)
            } else {
                request.cacheControl(CACHE_CONTROL_FORCE_NETWORK_NO_CACHE)
            }
            !networkRead && !diskRead -> {
                // This causes the request to fail with a 504 Unsatisfiable Request.
                request.cacheControl(CACHE_CONTROL_NO_NETWORK_NO_CACHE)
            }
        }

        val response = callFactory.newCall(request.build()).await()
        if (!response.isSuccessful) {
            response.body()?.close()
            throw HttpException(response)
        }
        val body = checkNotNull(response.body()) { "Null response body!" }

        return SourceResult(
            source = body.source(),
            mimeType = getMimeType(url, body),
            dataSource = if (response.cacheResponse() != null) DataSource.DISK else DataSource.NETWORK
        )
    }
    
}
```

# å…«ã€ç¼“å­˜æœºåˆ¶

Glide çš„ç¼“å­˜æœºåˆ¶æ˜¯åˆ†ä¸º**å†…å­˜ç¼“å­˜**å’Œ**ç£ç›˜ç¼“å­˜**ä¸¤å±‚ï¼ŒCoil åœ¨è¿™ä¸¤ä¸ªçš„åŸºç¡€ä¸Šè¿˜å¢åŠ äº†**ç½‘ç»œç¼“å­˜**è¿™ä¸€å±‚ï¼Œè¿™å¯ä»¥ä» ImageRequest çš„å‚æ•°çœ‹å‡ºæ¥ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œè¿™ä¸‰å±‚ç¼“å­˜æœºåˆ¶æ˜¯å…¨éƒ¨å¯ç”¨çš„ï¼Œå³å…¨éƒ¨å¯è¯»å¯å†™

```kotlin
//å†…å­˜ç¼“å­˜
val memoryCachePolicy: CachePolicy,
//ç£ç›˜ç¼“å­˜
val diskCachePolicy: CachePolicy,
//ç½‘ç»œç¼“å­˜
val networkCachePolicy: CachePolicy,
```

```kotlin
enum class CachePolicy(
    val readEnabled: Boolean,
    val writeEnabled: Boolean
) {
    ENABLED(true, true),
    READ_ONLY(true, false),
    WRITE_ONLY(false, true),
    DISABLED(false, false)
}
```

åœ¨è¯·æ±‚å›¾ç‰‡çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ lambda å—ä¸­é…ç½®æœ¬æ¬¡è¯·æ±‚çš„ç¼“å­˜ç­–ç•¥

```kotlin
imageView.load(imageUrl) {
    memoryCachePolicy(CachePolicy.ENABLED)
    diskCachePolicy(CachePolicy.ENABLED)
    networkCachePolicy(CachePolicy.ENABLED)
}
```

ä¸‹é¢æ¥çœ‹çœ‹ Coil çš„ç¼“å­˜æœºåˆ¶å…·ä½“æ˜¯å¦‚ä½•å®šä¹‰å’Œå®ç°çš„

## 1ã€å†…å­˜ç¼“å­˜

Coil çš„å†…å­˜ç¼“å­˜æœºåˆ¶é›†ä¸­åœ¨ EngineInterceptor ä¸­ç”Ÿæ•ˆï¼Œæœ‰ä¸¤ä¸ªæ—¶æœºä¼šæ¥åˆ¤æ–­æ˜¯å¦å¯ä»¥å†™å…¥å’Œè¯»å–å†…å­˜ç¼“å­˜

1. å¦‚æœæœ¬æ¬¡è¯·æ±‚å…è®¸ä»å†…å­˜ä¸­è¯»å–ç¼“å­˜çš„è¯ï¼Œå³ `request.memoryCachePolicy.readEnabled` ä¸º trueï¼Œé‚£ä¹ˆå°±å°è¯•ä» memoryCacheService è¯»å–ç¼“å­˜
2. å¦‚æœæœ¬æ¬¡è¯·æ±‚å…è®¸å°†å›¾ç‰‡ç¼“å­˜åˆ°å†…å­˜çš„è¯ï¼Œå³ `request.memoryCachePolicy.writeEnabled` ä¸º trueï¼Œé‚£ä¹ˆå°±å°†å›¾ç‰‡å­˜åˆ° strongMemoryCache ä¸­

```kotlin
internal class EngineInterceptor(
    private val registry: ComponentRegistry,
    private val bitmapPool: BitmapPool,
    private val referenceCounter: BitmapReferenceCounter,
    private val strongMemoryCache: StrongMemoryCache,
    private val memoryCacheService: MemoryCacheService,
    private val requestService: RequestService,
    private val systemCallbacks: SystemCallbacks,
    private val drawableDecoder: DrawableDecoderService,
    private val logger: Logger?
) : Interceptor {
    
    override suspend fun intercept(chain: Interceptor.Chain): ImageResult {
        try {
            val request = chain.request           
            Â·Â·Â· 
            //å¦‚æœæœ¬æ¬¡å…è®¸ä½¿ç”¨å†…å­˜ç¼“å­˜çš„è¯ï¼Œé‚£ä¹ˆå°±å°è¯•ä» memoryCacheService ä¸­è·å–ç¼“å­˜
            val value = if (request.memoryCachePolicy.readEnabled) memoryCacheService[memoryCacheKey] else null
            Â·Â·Â·
            return withContext(request.dispatcher) {
                Â·Â·Â·
                //å°è¯•å°†è·å–åˆ°çš„ bitmap ç¼“å­˜åˆ° strongMemoryCache ä¸­
                val isCached = writeToMemoryCache(request, memoryCacheKey, drawable, isSampled)
                Â·Â·Â·
            }
        } catch (throwable: Throwable) {
            Â·Â·Â·
        }
    }
    
    private fun writeToMemoryCache(
        request: ImageRequest,
        key: MemoryCache.Key?,
        drawable: Drawable,
        isSampled: Boolean
    ): Boolean {
        if (!request.memoryCachePolicy.writeEnabled) {
            return false
        }

        if (key != null) {
            val bitmap = (drawable as? BitmapDrawable)?.bitmap
            if (bitmap != null) {
                strongMemoryCache.set(key, bitmap, isSampled)
                return true
            }
        }
        return false
    }
    
}
```

MemoryCacheService ç›¸å½“äºä¸€ä¸ªå·¥å…·ç±»ï¼Œä¼šå…ˆåå°è¯•ä» StrongMemoryCache å’Œ WeakMemoryCache å–å€¼ï¼Œå–å¾—åˆ°çš„è¯ä¼šåŒæ—¶é€šè¿‡ BitmapReferenceCounter å°†å…¶å¼•ç”¨è®¡æ•° +1

```kotlin
internal class MemoryCacheService(
    private val referenceCounter: BitmapReferenceCounter,
    private val strongMemoryCache: StrongMemoryCache,
    private val weakMemoryCache: WeakMemoryCache
) {

    operator fun get(key: MemoryCache.Key?): RealMemoryCache.Value? {
        key ?: return null
        val value = strongMemoryCache.get(key) ?: weakMemoryCache.get(key)
        if (value != null) referenceCounter.increment(value.bitmap)
        return value
    }
}
```

Coil çš„å†…å­˜ç¼“å­˜æœºåˆ¶å®é™…ä¸Šæ˜¯åˆ†ä¸ºä¸¤çº§ï¼š

1. WeakMemoryCache
2. StrongMemoryCache

åœ¨é»˜è®¤æƒ…å†µä¸‹ï¼ŒCoil çš„è¿™ä¸¤çº§å†…å­˜ç¼“å­˜éƒ½æ˜¯å¼€å¯çš„ï¼Œè¿™ä¸¤è€…çš„å…³ç³»æ˜¯ï¼š

1. RealWeakMemoryCacheã€‚é€šè¿‡å¼±å¼•ç”¨æ¥ä¿å­˜æ›¾ç»åŠ è½½åˆ°å†…å­˜ä¸­çš„ Bitmap
2. RealBitmapPoolã€‚Bitmap ç¼“å­˜æ± ï¼Œç”¨äºåœ¨å†…å­˜ä¸­ç¼“å­˜å½“å‰ä¸å†è¢«ä½¿ç”¨çš„ Bitmapï¼Œå¯ç”¨äºåç»­å¤ç”¨
3. RealBitmapReferenceCounterã€‚RealBitmapReferenceCounter ä¹Ÿé€šè¿‡å¼±å¼•ç”¨æ¥ä¿å­˜ Bitmapï¼Œç”¨äºå¯¹å½“å‰å¤„äºä½¿ç”¨çŠ¶æ€çš„ Bitmap è¿›è¡Œå¼•ç”¨æ ‡è®°ï¼Œè®¡ç®—æ¯ä¸ª Bitmap å½“å‰çš„å¼•ç”¨æ¬¡æ•°åŠå¯ç”¨çŠ¶æ€ã€‚ä¾‹å¦‚ï¼Œå½“ EngineInterceptor åœ¨ StrongMemoryCache ä¸­æ‰¾åˆ°äº†å¯ä»¥å¤ç”¨çš„ Bitmap åï¼Œè¯¥ Bitmap çš„å¼•ç”¨è®¡æ•°å°±ä¼š +1ã€‚å½“ StrongMemoryCache ç”±äºå®¹é‡é™åˆ¶éœ€è¦ç§»é™¤æŸä¸ª Bitmap æ—¶ï¼Œè¯¥ Bitmap çš„å¼•ç”¨è®¡æ•°å°±ä¼š -1ã€‚å½“ Bitmap çš„å¼•ç”¨æ¬¡æ•°å˜ä¸º 0 ä¸”å¤„äºä¸å¯ç”¨çŠ¶æ€æ—¶ï¼Œå°±ä¼šå°†å…¶ä» RealWeakMemoryCache ä¸­ç§»é™¤å¹¶å­˜åˆ° BitmapPool ä¸­
4. RealStrongMemoryCacheã€‚RealStrongMemoryCache é€šè¿‡æœ€è¿‘æœ€å°‘ä½¿ç”¨ç®—æ³• LruCache æ¥ç¼“å­˜ Bitmapï¼Œå¹¶ä¸”æ˜¯é€šè¿‡å¼ºå¼•ç”¨çš„æ–¹å¼æ¥ä¿å­˜ã€‚å½“ EngineInterceptor åŠ è½½åˆ°ä¸€ä¸ª Bitmap åï¼Œå°±ä¼šå°†å…¶å­˜åˆ° RealStrongMemoryCache çš„ LruCache ä¸­ï¼Œå¹¶åŒæ—¶å°† RealBitmapReferenceCounter çš„å¼•ç”¨è®¡æ•° +1ï¼Œåœ¨ç§»é™¤å…ƒç´ æ—¶ä¹Ÿä¼šç›¸åº”å‡å°‘å¼•ç”¨è®¡æ•°

è¿™ä¸¤çº§ç¼“å­˜çš„è®¾è®¡åˆè¡·æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿæˆ–è€…è¯´ï¼Œå°†å†…å­˜ç¼“å­˜è®¾è®¡ä¸ºè¿™ä¸¤å±‚æ˜¯å› ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ

æˆ‘ä»¬éƒ½çŸ¥é“ï¼Œå¼±å¼•ç”¨æ˜¯ä¸ä¼šé˜»æ­¢å†…å­˜å›æ”¶çš„ï¼Œä¸€ä¸ªå¯¹è±¡å¦‚æœåªå…·å¤‡å¼±å¼•ç”¨ï¼Œé‚£ä¹ˆåœ¨ GC è¿‡åè¯¥å¯¹è±¡å°±ä¼šè¢«å›æ”¶ï¼Œæ‰€ä»¥ RealWeakMemoryCache çš„å­˜åœ¨ä¸ä¼šå¯¼è‡´ Bitmap è¢«æ³„æ¼ã€‚è€Œ RealStrongMemoryCache æ˜¯é€šè¿‡å¼ºå¼•ç”¨å’Œ LruCache æ¥å­˜å‚¨ Bitmap çš„ï¼Œç”±äº LruCache å…·æœ‰å›ºå®šå®¹é‡ï¼Œé‚£ä¹ˆå°±å­˜åœ¨ç”±äºå®¹é‡ä¸è¶³å¯¼è‡´ç”¨æˆ·å½“å‰æ­£åœ¨ä½¿ç”¨çš„ Bitmap è¢«ç§»å‡º LruCache çš„å¯èƒ½ï¼Œå¦‚æœä¹‹ååˆéœ€è¦åŠ è½½åŒä¸€ä¸ª Bitmap çš„è¯ï¼Œå°±è¿˜å¯ä»¥é€šè¿‡ RealWeakMemoryCache æ¥å–å€¼ï¼Œå°½é‡å¤ç”¨å·²ç»åŠ è½½åœ¨å†…å­˜ä¸­çš„ Bitmapã€‚æ‰€ä»¥è¯´ï¼ŒRealStrongMemoryCache å’Œ RealWeakMemoryCache çš„å­˜åœ¨æ„ä¹‰éƒ½æ˜¯ä¸ºäº†å°½é‡å¤ç”¨ Bitmap

æ­¤å¤–ï¼ŒBitmapPool çš„å­˜åœ¨æ„ä¹‰æ˜¯ä¸ºäº†å°½é‡é¿å…é¢‘ç¹åˆ›å»º Bitmapã€‚åœ¨ä½¿ç”¨ Transformation çš„æ—¶å€™éœ€è¦ç”¨åˆ° Bitmap æ¥ä½œä¸ºè½½ä½“ï¼Œå¦‚æœé¢‘ç¹åˆ›å»º Bitmap å¯èƒ½ä¼šé€ æˆå†…å­˜æŠ–åŠ¨ï¼Œæ‰€ä»¥å³ä½¿å½“ä¸€ä¸ª Bitmap ä¸å†è¢«ä½¿ç”¨ï¼Œä¹Ÿä¼šå°†ä¹‹å­˜åˆ° RealBitmapPool ä¸­ç¼“å­˜èµ·æ¥ï¼Œæ–¹ä¾¿åç»­å¤ç”¨ã€‚RealBitmapReferenceCounter ä¼šä¿å­˜ Bitmap çš„å¼•ç”¨æ¬¡æ•°å’Œå¯ç”¨çŠ¶æ€ï¼Œå½“å¼•ç”¨æ¬¡æ•°å°äºç­‰äº 0 ä¸”å¤„äºä¸å¯ç”¨çŠ¶æ€æ—¶ï¼Œå°±ä¼šå°†å…¶ä» RealWeakMemoryCache ä¸­ç§»é™¤å¹¶å­˜åˆ° BitmapPool ä¸­

## 2ã€ç£ç›˜ç¼“å­˜ã€ç½‘ç»œç¼“å­˜

Coil çš„**ç£ç›˜ç¼“å­˜**å’Œ**ç½‘ç»œç¼“å­˜**å¯ä»¥åˆåœ¨ä¸€èµ·è®²ï¼Œå› ä¸º Coil çš„ç£ç›˜ç¼“å­˜å…¶å®æ˜¯é€šè¿‡ OkHttp æœ¬èº«çš„ç½‘ç»œç¼“å­˜åŠŸèƒ½æ¥é—´æ¥å®ç°çš„ã€‚RealImageLoader åœ¨åˆå§‹åŒ–çš„æ—¶å€™ï¼Œé»˜è®¤æ„å»ºäº†ä¸€ä¸ªåŒ…å« cache çš„ OkHttpClientï¼Œå³é»˜è®¤æ”¯æŒç¼“å­˜ç½‘ç»œè¯·æ±‚ç»“æœ

```kotlin
private fun buildDefaultCallFactory() = lazyCallFactory {
    OkHttpClient.Builder()
        .cache(CoilUtils.createDefaultCache(applicationContext))
        .build()
}
```

è€Œä¸”ï¼ŒCoil çš„ç£ç›˜ç¼“å­˜å’Œç½‘ç»œç¼“å­˜è¿™ä¸¤ä¸ªé…ç½®ä¹Ÿåªä¼šåœ¨ HttpFetcher è¿™é‡Œè¯»å–ï¼Œå³åªåœ¨è¿›è¡Œç½‘ç»œè¯·æ±‚çš„æ—¶å€™ç”Ÿæ•ˆï¼Œæ‰€ä»¥è¯´ï¼ŒCoil **åªä¼šç£ç›˜ç¼“å­˜é€šè¿‡ç½‘ç»œè¯·æ±‚å¾—åˆ°çš„åŸå§‹å›¾ç‰‡ï¼Œè€Œä¸ç¼“å­˜å…¶å®ƒå°ºå¯¸å¤§å°çš„å›¾ç‰‡**

HttpFetcher çš„ç½‘ç»œç¼“å­˜å’Œç£ç›˜ç¼“å­˜ç­–ç•¥æ˜¯é€šè¿‡ä¿®æ”¹ Request çš„ **cacheControl** æ¥å®ç°çš„ï¼Œæ¯ç§ç¼“å­˜ç­–ç•¥å¯ä»¥åˆ†åˆ«é…ç½®æ˜¯å¦å¯è¯»å¯å†™ï¼Œä¸€å…±æœ‰ä»¥ä¸‹å‡ ç§å¯èƒ½ï¼š

1. ä¸å…è®¸ç½‘ç»œè¯·æ±‚ï¼Œå…è®¸ç£ç›˜è¯»ç¼“å­˜ã€‚é‚£ä¹ˆå°±å¼ºåˆ¶ä½¿ç”¨æœ¬åœ°ç¼“å­˜ï¼Œå¦‚æœæœ¬åœ°ç¼“å­˜ä¸å­˜åœ¨çš„è¯å°±æŠ¥é”™ï¼ŒåŠ è½½å¤±è´¥
2. å…è®¸ç½‘ç»œè¯·æ±‚ï¼Œä¸å…è®¸ç£ç›˜è¯»ç¼“å­˜
   1. å…è®¸ç£ç›˜å†™ç¼“å­˜ã€‚é‚£ä¹ˆå°±å¼ºåˆ¶å»ç½‘ç»œè¯·æ±‚ï¼Œä¸”å°†è¯·æ±‚ç»“æœç¼“å­˜åˆ°æœ¬åœ°ç£ç›˜
   2. ä¸å…è®¸ç£ç›˜å†™ç¼“å­˜ã€‚é‚£ä¹ˆå°±å¼ºåˆ¶å»ç½‘ç»œè¯·æ±‚ï¼Œä¸”ä¸å°†è¯·æ±‚ç»“æœç¼“å­˜åˆ°æœ¬åœ°ç£ç›˜
3. ä¸å…è®¸ç½‘ç»œè¯·æ±‚ï¼Œä¸å…è®¸ç£ç›˜è¯»ç¼“å­˜ã€‚è¿™ä¼šå¯¼è‡´è¯·æ±‚å¤±è´¥ï¼ŒHttp æŠ¥ 504 é”™è¯¯ï¼ŒåŠ è½½å¤±è´¥
4. å…è®¸ç½‘ç»œè¯·æ±‚ï¼Œä¹Ÿå…è®¸ç£ç›˜è¯»ç¼“å­˜å’Œç£ç›˜å†™ç¼“å­˜ã€‚é‚£ä¹ˆå°±ä¼šä¼˜å…ˆä½¿ç”¨æœ¬åœ°ç¼“å­˜ï¼Œæœ¬åœ°ç¼“å­˜ä¸å­˜åœ¨çš„è¯å†å»ç½‘ç»œè¯·æ±‚ï¼Œå¹¶å°†ç½‘ç»œè¯·æ±‚ç»“æœç¼“å­˜åˆ°æœ¬åœ°ç£ç›˜

```kotlin
internal abstract class HttpFetcher<T : Any>(private val callFactory: Call.Factory) : Fetcher<T> {

    /**
     * Perform this conversion in a [Fetcher] instead of a [Mapper] so
     * [HttpUriFetcher] can execute [HttpUrl.get] on a background thread.
     */
    abstract fun T.toHttpUrl(): HttpUrl

    override suspend fun fetch(
        pool: BitmapPool,
        data: T,
        size: Size,
        options: Options
    ): FetchResult {
        val url = data.toHttpUrl()
        val request = Request.Builder().url(url).headers(options.headers)

        val networkRead = options.networkCachePolicy.readEnabled
        val diskRead = options.diskCachePolicy.readEnabled
        when {
            //1ã€ä¸å…è®¸ç½‘ç»œè¯·æ±‚ï¼Œå…è®¸ç£ç›˜è¯»ç¼“å­˜
            //é‚£ä¹ˆå°±å¼ºåˆ¶ä½¿ç”¨æœ¬åœ°ç¼“å­˜ï¼Œå¦‚æœä¸å­˜åœ¨æœ¬åœ°ç¼“å­˜çš„è¯å°±æŠ¥é”™
            !networkRead && diskRead -> {
                request.cacheControl(CacheControl.FORCE_CACHE)
            }
            //2ã€å…è®¸ç½‘ç»œè¯·æ±‚ï¼Œä¸å…è®¸ç£ç›˜è¯»ç¼“å­˜
            networkRead && !diskRead ->
                if (options.diskCachePolicy.writeEnabled) {
                    //2.1ã€å…è®¸ç£ç›˜å†™ç¼“å­˜
                    //é‚£ä¹ˆå°±å¼ºåˆ¶å»ç½‘ç»œè¯·æ±‚ï¼Œä¸”å°†è¯·æ±‚ç»“æœç¼“å­˜åˆ°æœ¬åœ°ç£ç›˜
                    request.cacheControl(CacheControl.FORCE_NETWORK)
                } else {
                    //2.2ã€ä¸å…è®¸ç£ç›˜å†™ç¼“å­˜
                    //é‚£ä¹ˆå°±å¼ºåˆ¶å»ç½‘ç»œè¯·æ±‚ï¼Œä¸”ä¸å°†è¯·æ±‚ç»“æœç¼“å­˜åˆ°æœ¬åœ°ç£ç›˜
                    request.cacheControl(CACHE_CONTROL_FORCE_NETWORK_NO_CACHE)
                }
            !networkRead && !diskRead -> {
                //3ã€ä¸å…è®¸ç½‘ç»œè¯·æ±‚ï¼Œä¸å…è®¸ç£ç›˜è¯»ç¼“å­˜
                //è¿™ä¼šå¯¼è‡´è¯·æ±‚å¤±è´¥ï¼Œå°±ä¼šå¯¼è‡´è¯·æ±‚å¤±è´¥ï¼ŒæŠ¥ 504 é”™è¯¯
                request.cacheControl(CACHE_CONTROL_NO_NETWORK_NO_CACHE)
            }
        }

        val response = callFactory.newCall(request.build()).await()
        if (!response.isSuccessful) {
            response.body()?.close()
            throw HttpException(response)
        }
        val body = checkNotNull(response.body()) { "Null response body!" }

        return SourceResult(
            source = body.source(),
            mimeType = getMimeType(url, body),
            dataSource = if (response.cacheResponse() != null) DataSource.DISK else DataSource.NETWORK
        )
    }

    Â·Â·Â·
}
```

ä»ä»¥ä¸Šé€»è¾‘ä¹Ÿå¯ä»¥çœ‹å‡ºï¼ŒnetworkCachePolicy çš„ writeEnabled å±æ€§å¹¶æ²¡æœ‰è¢«ç”¨åˆ°ï¼Œå› ä¸ºç½‘ç»œè¯·æ±‚æœ¬èº«åªæœ‰**å‘èµ·**å’Œ**ä¸å‘èµ·**ä¸¤ç§é€‰æ‹©ï¼Œç”¨ readEnabled å°±è¶³å¤Ÿè¡¨ç¤ºäº†ï¼Œæ‰€ä»¥ writeEnabled å¯¹äº networkCachePolicy æ¥è¯´æ²¡æœ‰æ„ä¹‰

æ­¤å¤–ï¼Œä¸ºäº†åœ¨æ— ç½‘ç»œä¿¡å·çš„æ—¶å€™å¯ä»¥å¿«é€Ÿç»“æŸæ•´ä¸ªæµç¨‹ï¼Œé¿å…æ— æ„ä¹‰çš„ç½‘ç»œè¯·æ±‚ï¼ŒRequestService ä¼šåœ¨å½“å‰å¤„äºç¦»çº¿çš„æ—¶å€™ï¼ˆå³ isOnline ä¸º falseï¼‰ï¼Œå°† networkCachePolicy ä¿®æ”¹ä¸ºå®Œå…¨ç¦ç”¨çŠ¶æ€ï¼ˆCachePolicy.DISABLEDï¼‰

```kotlin
internal class RequestService(private val logger: Logger?) {
    
    @WorkerThread
    fun options(
        request: ImageRequest,
        size: Size,
        isOnline: Boolean
    ): Options {
       	Â·Â·Â·
        // Disable fetching from the network if we know we're offline.
        val networkCachePolicy = if (isOnline) request.networkCachePolicy else CachePolicy.DISABLED
     	Â·Â·Â·
        return Options(
            context = request.context,
            config = config,
            colorSpace = request.colorSpace,
            scale = request.scale,
            allowInexactSize = request.allowInexactSize,
            allowRgb565 = allowRgb565,
            premultipliedAlpha = request.premultipliedAlpha,
            headers = request.headers,
            parameters = request.parameters,
            memoryCachePolicy = request.memoryCachePolicy,
            diskCachePolicy = request.diskCachePolicy,
            networkCachePolicy = networkCachePolicy
        )
    }

    
}
```

# ä¹ã€ç”Ÿå‘½å‘¨æœŸç›‘å¬

å‰æ–‡æœ‰æåˆ°ï¼Œæ¯ä¸ª ImageRequest éƒ½ä¼šå…³è”ä¸€ä¸ª Context å¯¹è±¡ï¼Œå¦‚æœå¤–éƒ¨ä¼ å…¥çš„æ˜¯ ImageViewï¼Œåˆ™ä¼šè‡ªåŠ¨å– ImageView å†…éƒ¨çš„ Contextã€‚Coil ä¼šåˆ¤æ–­ Context æ˜¯å¦å±äº LifecycleOwner ç±»å‹ï¼Œæ˜¯çš„è¯åˆ™å¯ä»¥æ‹¿åˆ°**å’Œ Activity æˆ–è€… Fragment å…³è”çš„ Lifecycle**ï¼Œå¦åˆ™æœ€ç»ˆå– **GlobalLifecycle**

å’Œ Activity æˆ–è€… Fragment å…³è”çš„ Lifecycle æ‰**å…·å¤‡æœ‰ç”Ÿå‘½å‘¨æœŸæ„ŸçŸ¥èƒ½åŠ›**ï¼Œè¿™æ · Coil æ‰å¯ä»¥åœ¨ Activity å¤„äºåå°æˆ–è€…å·²ç»é”€æ¯çš„æ—¶å€™æš‚åœæˆ–è€…åœæ­¢ä»»åŠ¡ã€‚è€Œ GlobalLifecycle ä¼šé»˜è®¤ä¸”ä¸€ç›´ä¼šå¤„äº RESUMED çŠ¶æ€ï¼Œè¿™æ ·ä»»åŠ¡å°±ä¼šä¸€ç›´è¿è¡Œç›´åˆ°æœ€ç»ˆç»“æŸï¼Œè¿™å¯èƒ½å¯¼è‡´å†…å­˜æ³„éœ²

é‚£ä¹ˆï¼Œè¯¥  Lifecycle å¯¹è±¡å…·ä½“æ˜¯åœ¨ä»€ä¹ˆåœ°æ–¹èµ·äº†ä½œç”¨å‘¢ï¼Ÿ

è¿™ä¸ªä¸»è¦çœ‹ RealImageLoader çš„ `executeMain` æ–¹æ³•ã€‚åœ¨å‘èµ·å›¾ç‰‡åŠ è½½è¯·æ±‚å‰ï¼Œåå…ˆåˆ›å»º request çš„ä»£ç†å¯¹è±¡ requestDelegateï¼ŒrequestDelegate ä¸­å°±åŒ…å«äº†å¯¹ Lifecycle çš„å¤„ç†é€»è¾‘ã€‚æ­¤å¤–ï¼Œå¦‚æœæ˜¯å¼‚æ­¥è¯·æ±‚çš„è¯ï¼Œä¼šç­‰åˆ° Lifecycle è‡³å°‘å¤„äº Started çŠ¶æ€ä¹‹åæ‰èƒ½å‘èµ·è¯·æ±‚ï¼Œè¿™æ ·å½“ Activity è¿˜å¤„äºåå°æ—¶å°±ä¸ä¼šå‘èµ·è¯·æ±‚äº†

```kotlin
@MainThread
private suspend fun executeMain(initialRequest: ImageRequest, type: Int): ImageResult {
    Â·Â·Â·

    //åˆ›å»º request çš„ä»£ç†å¯¹è±¡
    val requestDelegate = delegateService.createRequestDelegate(request, targetDelegate, coroutineContext.job)

    try {
        Â·Â·Â·

        //å¦‚æœæ˜¯å¼‚æ­¥è¯·æ±‚çš„è¯ï¼Œé‚£ä¹ˆå°±éœ€è¦ç­‰åˆ° Lifecycle è‡³å°‘å¤„äº Started çŠ¶æ€ä¹‹åæ‰èƒ½ç»§ç»­æ‰§è¡Œ
        if (type == REQUEST_TYPE_ENQUEUE) request.lifecycle.awaitStarted()

        Â·Â·Â·
        return result
    } catch (throwable: Throwable) {
        if (throwable is CancellationException) {
            onCancel(request, eventListener)
            throw throwable
        } else {
            // Create the default error result if there's an uncaught exception.
            val result = requestService.errorResult(request, throwable)
            onError(result, targetDelegate, eventListener)
            return result
        }
    } finally {
        requestDelegate.complete()
    }
}
```

`createRequestDelegate` æ–¹æ³•çš„é€»è¾‘å¯ä»¥æ€»ç»“ä¸ºï¼š

1. å¦‚æœ target å¯¹è±¡å±äº ViewTarget ç±»å‹ï¼Œé‚£ä¹ˆè¯´æ˜å…¶åŒ…å«ç‰¹å®š View
   - å°†è¯·æ±‚è¯·æ±‚å‚æ•°åŒ…è£…ä¸º ViewTargetRequestDelegate ç±»å‹ï¼Œè€Œ ViewTargetRequestDelegate å®ç°äº† DefaultLifecycleObserver æ¥å£ï¼Œå…¶ä¼šåœ¨æ”¶åˆ° onDestroy äº‹ä»¶çš„æ—¶å€™ä¸»åŠ¨å–æ¶ˆ Job å¹¶æ¸…ç†å„ç±»èµ„æºã€‚æ‰€ä»¥å‘ Lifecycle æ·»åŠ è¯¥ Observer å°±å¯ä»¥ä¿è¯åœ¨ Activity é”€æ¯åä¹Ÿèƒ½åŒæ—¶å–æ¶ˆå›¾ç‰‡åŠ è½½è¯·æ±‚ï¼Œé¿å…å†…å­˜æ³„æ¼
   - å¦‚æœ target å±äº LifecycleObserver ç±»å‹çš„è¯ï¼Œåˆ™ä¹Ÿå‘ Lifecycle æ·»åŠ è¯¥ Observer ã€‚ImageViewTarget å°±å®ç°äº† DefaultLifecycleObserver æ¥å£ï¼Œè¿™ä¸»è¦æ˜¯ä¸ºäº†åˆ¤æ–­ ImageView å¯¹åº”çš„ Activity æˆ–è€… Fragment æ˜¯å¦å¤„äºå‰å°ï¼Œå¦‚æœå¤„äºå‰å°ä¸”å­˜åœ¨ Animatable çš„è¯å°±ä¼šè‡ªåŠ¨å¯åŠ¨åŠ¨ç”»ï¼Œå¦åˆ™å°±è‡ªåŠ¨åœæ­¢åŠ¨ç”»ã€‚ä¹‹æ‰€ä»¥éœ€è¦å…ˆ removeObserver å† addObserverï¼Œæ˜¯å› ä¸º target å¯èƒ½éœ€è¦å…ˆåè¯·æ±‚å¤šå¼ å›¾ç‰‡ï¼Œæˆ‘ä»¬ä¸èƒ½é‡å¤å‘ Lifecycle æ·»åŠ åŒä¸€ä¸ª Observer å¯¹è±¡
   - åŒæ—¶ï¼Œå¦‚æœ View å·²ç» Detached äº†çš„è¯ï¼Œé‚£ä¹ˆå°±éœ€è¦ä¸»åŠ¨å–æ¶ˆè¯·æ±‚
2. å¦‚æœ  target å¯¹è±¡ä¸å±äº ViewTarget ç±»å‹çš„è¯ï¼Œåˆ›å»ºçš„ä»£ç†å¯¹è±¡æ˜¯ BaseRequestDelegate ç±»å‹ï¼Œä¹Ÿä¼šåœ¨æ”¶åˆ° onDestroy äº‹ä»¶çš„æ—¶å€™ä¸»åŠ¨å–æ¶ˆ Job

```kotlin
/** Wrap [request] to automatically dispose (and for [ViewTarget]s restart) the [ImageRequest] based on its lifecycle. */
@MainThread
fun createRequestDelegate(
    request: ImageRequest,
    targetDelegate: TargetDelegate,
    job: Job
): RequestDelegate {
    val lifecycle = request.lifecycle
    val delegate: RequestDelegate
    when (val target = request.target) {
        //å¯¹åº”ç¬¬1ç‚¹
        is ViewTarget<*> -> {
            //å¯¹åº”ç¬¬1.1ç‚¹
            delegate = ViewTargetRequestDelegate(imageLoader, request, targetDelegate, job)
            lifecycle.addObserver(delegate)

            //å¯¹åº”ç¬¬1.2ç‚¹
            if (target is LifecycleObserver) {
                lifecycle.removeObserver(target)
                lifecycle.addObserver(target)
            }

            target.view.requestManager.setCurrentRequest(delegate)

            //å¯¹åº”ç¬¬1.3ç‚¹
            // Call onViewDetachedFromWindow immediately if the view is already detached.
            if (!target.view.isAttachedToWindowCompat) {
                target.view.requestManager.onViewDetachedFromWindow(target.view)
            }
        }
        //å¯¹åº”ç¬¬2ç‚¹
        else -> {
            delegate = BaseRequestDelegate(lifecycle, job)
            lifecycle.addObserver(delegate)
        }
    }
    return delegate
}
```

# åã€Transformation

å›¾ç‰‡å˜æ¢æ˜¯åŸºæœ¬æ‰€æœ‰çš„å›¾ç‰‡åŠ è½½åº“éƒ½ä¼šæ”¯æŒçš„åŠŸèƒ½ï¼ŒCoil å¯¹è¿™ä¸ªæ¦‚å¿µçš„æŠ½è±¡å³ Transformation æ¥å£

æ³¨æ„ï¼Œ`key()`æ–¹æ³•çš„è¿”å›å€¼æ˜¯ç”¨äºè®¡ç®—å›¾ç‰‡åœ¨å†…å­˜ç¼“å­˜ä¸­çš„å”¯ä¸€ Key æ—¶çš„è¾…åŠ©å‚æ•°ï¼Œæ‰€ä»¥éœ€è¦å®ç°è¯¥æ–¹æ³•ï¼Œä¸º Transformation ç”Ÿæˆä¸€ä¸ªå¯ä»¥å”¯ä¸€æ ‡è¯†è‡ªèº«çš„å­—ç¬¦ä¸² Keyã€‚`transform` æ–¹æ³•åŒ…å«äº†ä¸€ä¸ª BitmapPool å‚æ•°ï¼Œæˆ‘ä»¬åœ¨å®ç°å›¾å½¢å˜æ¢çš„æ—¶å€™å¾€å¾€æ˜¯éœ€è¦ä¸€ä¸ªå…¨æ–°çš„ Bitmapï¼Œæ­¤æ—¶å°±åº”è¯¥é€šè¿‡ BitmapPool æ¥è·å–ï¼Œå°½é‡å¤ç”¨å·²æœ‰çš„ Bitmap

```kotlin
interface Transformation {

    /**
     * Return a unique key for this transformation.
     *
     * The key should contain any params that are part of this transformation (e.g. size, scale, color, radius, etc.).
     */
    fun key(): String

    /**
     * Apply the transformation to [input].
     *
     * @param pool A [BitmapPool] which can be used to request [Bitmap] instances.
     * @param input The input [Bitmap] to transform. Its config will always be [Bitmap.Config.ARGB_8888] or [Bitmap.Config.RGBA_F16].
     * @param size The size of the image request.
     */
    suspend fun transform(pool: BitmapPool, input: Bitmap, size: Size): Bitmap
}
```

Coil é»˜è®¤æä¾›äº†ä»¥ä¸‹å‡ ä¸ª Transformation å®ç°ç±»

- BlurTransformationã€‚ç”¨äºå®ç°é«˜æ–¯æ¨¡ç³Š
- CircleCropTransformationã€‚ç”¨äºå°†å›¾ç‰‡è½¬æ¢ä¸ºåœ†å½¢
- GrayscaleTransformationã€‚ç”¨æˆ·å®ç°å°†å›¾ç‰‡è½¬æ¢ä¸ºç°è‰²
- RoundedCornersTransformationã€‚ç”¨äºä¸ºå›¾ç‰‡æ·»åŠ åœ†è§’

æˆ‘ä»¬å¯ä»¥å­¦ç€å®˜æ–¹ç»™çš„ä¾‹å­ï¼Œè‡ªå·±æ¥å®ç°ä¸¤ä¸ª Transformation 

## 1ã€ä¸ºå›¾ç‰‡æ·»åŠ æ°´å°

ä¸ºå›¾ç‰‡æ·»åŠ æ°´å°çš„æ€è·¯ä¹Ÿå¾ˆç®€å•ï¼Œåªéœ€è¦å¯¹ canvas ç¨å¾®åä¸‹æ—‹è½¬ï¼Œç„¶åç»˜åˆ¶æ–‡æœ¬å³å¯

```kotlin
/**
 * @Author: leavesCZY
 * @Githubï¼šhttps://github.com/leavesCZY
 * @Desc: ä¸ºå›¾ç‰‡æ·»åŠ æ°´å°
 */
class WatermarkTransformation(
    private val watermark: String,
    @ColorInt private val textColor: Int,
    private val textSize: Float
) : Transformation {

    override fun key(): String {
        return "${WatermarkTransformation::class.java.name}-${watermark}-${textColor}-${textSize}"
    }

    override suspend fun transform(pool: BitmapPool, input: Bitmap, size: Size): Bitmap {
        val width = input.width
        val height = input.height
        val config = input.config

        val output = pool.get(width, height, config)

        val canvas = Canvas(output)
        val paint = Paint()
        paint.isAntiAlias = true
        canvas.drawBitmap(input, 0f, 0f, paint)

        canvas.rotate(40f, width / 2f, height / 2f)

        paint.textSize = textSize
        paint.color = textColor

        val textWidth = paint.measureText(watermark)

        canvas.drawText(watermark, (width - textWidth) / 2f, height / 2f, paint)

        return output
    }

}
```

```kotlin
imageView.load(imageUrl) {
    transformations(
        WatermarkTransformation("ä¸šå¿—é™ˆ", Color.parseColor("#8D3700B3"), 120f)
    )
}
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0342c509ce3340a5b82a6e342c1b8916~tplv-k3u1fbpfcp-zoom-1.image)

## 2ã€ä¸ºå›¾ç‰‡æ·»åŠ è’™å±‚

Android çš„ Paint åŸç”Ÿå°±æ”¯æŒä¸º Bitmap æ·»åŠ ä¸€ä¸ªè’™å±‚ï¼Œåªéœ€è¦ä½¿ç”¨å…¶ `colorFilter`æ–¹æ³•å³å¯

```kotlin
/**
 * @Author: leavesCZY
 * @Githubï¼šhttps://github.com/leavesCZY
 * @Desc: æ·»åŠ è’™å±‚
 */
class ColorFilterTransformation(
    @ColorInt private val color: Int
) : Transformation {

    override fun key(): String = "${ColorFilterTransformation::class.java.name}-$color"

    override suspend fun transform(pool: BitmapPool, input: Bitmap, size: Size): Bitmap {
        val width = input.width
        val height = input.height
        val config = input.config
        val output = pool.get(width, height, config)

        val canvas = Canvas(output)
        val paint = Paint()
        paint.isAntiAlias = true
        paint.colorFilter = PorterDuffColorFilter(color, PorterDuff.Mode.SRC_ATOP)
        canvas.drawBitmap(input, 0f, 0f, paint)

        return output
    }
}
```

```kotlin
imageView.load(imageUrl) {
    transformations(
        WatermarkTransformation("ä¸šå¿—é™ˆ", Color.parseColor("#8D3700B3"), 120f),
        ColorFilterTransformation(Color.parseColor("#9CF44336"))
    )
}
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4417b3a98bc44258e0fe9395e73dc4e~tplv-k3u1fbpfcp-zoom-1.image)

æ›´å¤š Transformation æ•ˆæœçœ‹è¿™é‡Œï¼š[coil-transformations](https://github.com/Commit451/coil-transformations)

# åä¸€ã€å®ç°å…¨å±€é»˜è®¤é…ç½®

å¦‚æœæˆ‘ä»¬æƒ³è¦è®¾ç½®åº”ç”¨å†…æ‰€æœ‰å›¾ç‰‡åœ¨åŠ è½½æ—¶å›ºå®šæ˜¾ç¤ºåŒä¸€å¼  loading å›¾ï¼Œåœ¨åŠ è½½å¤±è´¥æ—¶å›ºå®šæ˜¾ç¤ºä¸€å¼  error å›¾ï¼Œ é‚£ä¹ˆå°±éœ€è¦ä¸º Coil è®¾å®šä¸€ä¸ªå…¨å±€çš„é»˜è®¤é…ç½®ã€‚Glide æ˜¯é€šè¿‡ AppGlideModule æ¥å®ç°çš„ï¼Œé‚£ Coil æ˜¯å¦‚ä½•æ¥å®ç°è¿™ä¸ªæ•ˆæœå‘¢ï¼Ÿ

Coil é»˜è®¤ä¼šåœ¨æˆ‘ä»¬ç¬¬ä¸€æ¬¡è§¦å‘å›¾ç‰‡åŠ è½½çš„æ—¶å€™æ¥åˆå§‹åŒ– RealImageLoader çš„å•ä¾‹å¯¹è±¡ï¼Œè€Œ RealImageLoader çš„æ„é€ å‚æ•°å°±åŒ…å«äº†ä¸€ä¸ª DefaultRequestOptions ç”¨äºè®¾ç½®é»˜è®¤é…ç½®ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡è‡ªå®šä¹‰ RealImageLoader çš„åˆå§‹åŒ–é€»è¾‘æ¥æ§åˆ¶å…¨å±€çš„é»˜è®¤è¯·æ±‚é…ç½®

```kotlin
internal class RealImageLoader(
    context: Context,
    override val defaults: DefaultRequestOptions,
    override val bitmapPool: BitmapPool,
    private val referenceCounter: BitmapReferenceCounter,
    private val strongMemoryCache: StrongMemoryCache,
    private val weakMemoryCache: WeakMemoryCache,
    callFactory: Call.Factory,
    private val eventListenerFactory: EventListener.Factory,
    componentRegistry: ComponentRegistry,
    addLastModifiedToFileCacheKey: Boolean,
    private val launchInterceptorChainOnMainThread: Boolean,
    val logger: Logger?
) 
```

RealImageLoader çš„å•ä¾‹å¯¹è±¡å°±ä¿å­˜åœ¨å¦ä¸€ä¸ªå•ä¾‹å¯¹è±¡ Coil ä¸­ï¼ŒCoil ä»¥ä¸¤ç§æ–¹å¼æ¥å®Œæˆ RealImageLoader çš„åˆå§‹åŒ–

- å¦‚æœé¡¹ç›®ä¸­çš„ Application ç»§æ‰¿äº† ImageLoaderFactory æ¥å£ï¼Œé‚£ä¹ˆå°±é€šè¿‡è¯¥æ¥å£æ¥å®Œæˆåˆå§‹åŒ–
- é€šè¿‡ `ImageLoader(context)` æ¥å®Œæˆé»˜è®¤åˆå§‹åŒ–

```kotlin
/**
 * A class that holds the singleton [ImageLoader] instance.
 */
object Coil {

    private var imageLoader: ImageLoader? = null
    private var imageLoaderFactory: ImageLoaderFactory? = null

    /**
     * Get the singleton [ImageLoader]. Creates a new instance if none has been set.
     */
    @JvmStatic
    fun imageLoader(context: Context): ImageLoader = imageLoader ?: newImageLoader(context)

    Â·Â·Â·

    /** Create and set the new singleton [ImageLoader]. */
    @Synchronized
    private fun newImageLoader(context: Context): ImageLoader {
        // Check again in case imageLoader was just set.
        imageLoader?.let { return it }

        // Create a new ImageLoader.
        val newImageLoader = imageLoaderFactory?.newImageLoader()
            ?: (context.applicationContext as? ImageLoaderFactory)?.newImageLoader()
            ?: ImageLoader(context)
        imageLoaderFactory = null
        imageLoader = newImageLoader
        return newImageLoader
    }
    
}
```

ä¸ºäº†è®¾å®šé»˜è®¤é…ç½®ï¼Œæˆ‘ä»¬å°±éœ€è¦**åœ¨åº”ç”¨å¯åŠ¨ä¹‹åï¼Œå¼€å§‹å›¾ç‰‡åŠ è½½ä¹‹å‰**å‘ Coil æ³¨å…¥è‡ªå·±çš„ ImageLoader å®ä¾‹

```kotlin
/**
 * @Author: leavesCZY
 * @Githubï¼šhttps://github.com/leavesCZY
 * @Desc:
 */
object CoilHolder {

    fun init(application: Application) {
        Coil.setImageLoader(
            ImageLoader.Builder(application)
                .placeholder(ActivityCompat.getDrawable(application, R.drawable.icon_loading)) //å ä½ç¬¦
                .error(ActivityCompat.getDrawable(application, R.drawable.icon_error)) //é”™è¯¯å›¾
                .memoryCachePolicy(CachePolicy.ENABLED) //å¼€å¯å†…å­˜ç¼“å­˜
                .callFactory(createOkHttp(application)) //ä¸»åŠ¨æ„é€  OkHttpClient å®ä¾‹
                .build()
        )
    }

    private fun createOkHttp(application: Application): OkHttpClient {
        return OkHttpClient.Builder()
            .cache(createDefaultCache(application))
            .build()
    }

    private fun createDefaultCache(context: Context): Cache {
        val cacheDirectory = getDefaultCacheDirectory(context)
        return Cache(cacheDirectory, 10 * 1024 * 1024)
    }

    private fun getDefaultCacheDirectory(context: Context): File {
        return File(context.cacheDir, "image_cache").apply { mkdirs() }
    }

}
```

# åäºŒã€è‡ªå®šä¹‰ç½‘ç»œè¯·æ±‚

åœ¨è®² Coil çš„**ç£ç›˜ç¼“å­˜**å’Œ**ç½‘ç»œç¼“å­˜**è¿™ä¸€èŠ‚å†…å®¹çš„æ—¶å€™æœ‰æåˆ°ï¼ŒCoil çš„ç½‘ç»œè¯·æ±‚æ˜¯ç”± HttpFetcher æ¥å®Œæˆçš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ˜¯å¦æœ‰åŠæ³•æ¥æ›¿æ¢è¯¥ç»„ä»¶ï¼Œè‡ªå·±æ¥å®ç°ç½‘ç»œè¯·æ±‚å‘¢ï¼Ÿå…ˆæ¥çœ‹ä¸‹ Coil æ˜¯å¦‚ä½•å®ç°å°†å¤–éƒ¨ä¼ å…¥çš„å›¾ç‰‡åœ°å€å’Œç‰¹å®šçš„ Fetcher å¯¹åº”ä¸Šçš„

RealImageLoader åŒ…å«ä¸€ä¸ª registry å˜é‡ï¼Œå…¶åŒ…å«çš„ Mapper å’Œ Fetcher å°±ç”¨äºå®ç°æ•°æ®æ˜ å°„

```kotlin
internal class RealImageLoader(
    context: Context,
    override val defaults: DefaultRequestOptions,
    override val bitmapPool: BitmapPool,
    private val referenceCounter: BitmapReferenceCounter,
    private val strongMemoryCache: StrongMemoryCache,
    private val weakMemoryCache: WeakMemoryCache,
    callFactory: Call.Factory,
    private val eventListenerFactory: EventListener.Factory,
    componentRegistry: ComponentRegistry,
    addLastModifiedToFileCacheKey: Boolean,
    private val launchInterceptorChainOnMainThread: Boolean,
    val logger: Logger?
) : ImageLoader {
    
 	private val registry = componentRegistry.newBuilder()
        // Mappers
        .add(StringMapper())
        .add(FileUriMapper())
        .add(ResourceUriMapper(context))
        .add(ResourceIntMapper(context))
        // Fetchers
        .add(HttpUriFetcher(callFactory))
        .add(HttpUrlFetcher(callFactory))
        .add(FileFetcher(addLastModifiedToFileCacheKey))
        .add(AssetUriFetcher(context))
        .add(ContentUriFetcher(context))
        .add(ResourceUriFetcher(context, drawableDecoder))
        .add(DrawableFetcher(drawableDecoder))
        .add(BitmapFetcher())
        // Decoders
        .add(BitmapFactoryDecoder(context))
        .build()
    
}
```

å¤–éƒ¨åœ¨è°ƒç”¨ `load` æ–¹æ³•æ—¶ï¼Œä¼ å…¥çš„ String å‚æ•°å¯èƒ½æ˜¯å®Œå…¨ä¸åŒçš„å«ä¹‰ï¼Œæ—¢å¯èƒ½æ˜¯æŒ‡å‘æœ¬åœ°èµ„æºæ–‡ä»¶ï¼Œä¹Ÿå¯èƒ½æ˜¯æŒ‡å‘è¿œç¨‹çš„ç½‘ç»œå›¾ç‰‡ï¼ŒCoil å°±ä¾é  Mapper å’Œ Fetcher æ¥åŒºåˆ†èµ„æºç±»å‹

```kotlin
imageView.load("android.resource://example.package.name/drawable/image")

imageView.load("https://www.example.com/image.jpg")
```

StringMapper é¦–å…ˆä¼šå°† String ç±»å‹è½¬æ¢ä¸º Uri

```kotlin
internal class StringMapper : Mapper<String, Uri> {

    override fun map(data: String) = data.toUri()
}
```

ResourceUriFetcher ä¼šæ‹¿åˆ° Uriï¼Œç„¶ååˆ¤æ–­ Uri çš„ `scheme` æ˜¯å¦æ˜¯ `android.resource`ï¼Œæ˜¯çš„è¯å°±çŸ¥é“å…¶æŒ‡å‘çš„æ˜¯æœ¬åœ°çš„èµ„æºæ–‡ä»¶ã€‚HttpUriFetcher åˆ™æ˜¯åˆ¤æ–­ Uri çš„ `scheme` æ˜¯å¦æ˜¯`http`æˆ–è€…`https`ï¼Œæ˜¯çš„è¯å°±çŸ¥é“å…¶æŒ‡å‘çš„æ˜¯è¿œç¨‹ç½‘ç»œå›¾ç‰‡

```kotlin
internal class ResourceUriFetcher(
    private val context: Context,
    private val drawableDecoder: DrawableDecoderService
) : Fetcher<Uri> {

    override fun handles(data: Uri) = data.scheme == ContentResolver.SCHEME_ANDROID_RESOURCE
    
}


internal class HttpUriFetcher(callFactory: Call.Factory) : HttpFetcher<Uri>(callFactory) {

    override fun handles(data: Uri) = data.scheme == "http" || data.scheme == "https"

    override fun key(data: Uri) = data.toString()

    override fun Uri.toHttpUrl(): HttpUrl = HttpUrl.get(toString())
    
}
```

ä»¥ä¸Šè¿™ä¸ª**è½¬æ¢+åˆ¤æ–­+åŠ è½½**çš„è¿‡ç¨‹å°±å‘ç”Ÿåœ¨ EngineInterceptor ä¸­

```kotlin
internal class EngineInterceptor(
    private val registry: ComponentRegistry,
    private val bitmapPool: BitmapPool,
    private val referenceCounter: BitmapReferenceCounter,
    private val strongMemoryCache: StrongMemoryCache,
    private val memoryCacheService: MemoryCacheService,
    private val requestService: RequestService,
    private val systemCallbacks: SystemCallbacks,
    private val drawableDecoder: DrawableDecoderService,
    private val logger: Logger?
) : Interceptor {
    
    override suspend fun intercept(chain: Interceptor.Chain): ImageResult {
        Â·Â·Â·
        //å°†å¤–éƒ¨ä¼ å…¥çš„æ•°æ®è¿›è¡Œç±»å‹è½¬æ¢
        val mappedData = registry.mapData(data)
        //æ‰¾åˆ°èƒ½å¤„ç†æœ¬æ¬¡è¯·æ±‚çš„ fetcher
        val fetcher = request.fetcher(mappedData) ?: registry.requireFetcher(mappedData)
        
        Â·Â·Â·
        
    }
    
}
```

æ‰€ä»¥ï¼Œè¦è‡ªå®šä¹‰ç½‘ç»œè¯·æ±‚ç»„ä»¶ï¼Œæˆ‘ä»¬å°±éœ€è¦å‘ ComponentRegistry æ·»åŠ è‡ªå·±çš„ HttpFetcher å®ç°ï¼Œåœ¨æ‹¿åˆ° Uri ç±»å‹çš„ç½‘ç»œåœ°å€åå‘èµ·ç½‘ç»œè¯·æ±‚ã€‚è¿™é‡Œæˆ‘æ¥å†™ä¸€ä¸ªé€šè¿‡ Volley æ¥å®Œæˆç½‘ç»œå›¾ç‰‡åŠ è½½çš„ VolleyFetcherã€‚**éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘å†™çš„ VolleyFetcher å¹¶ä¸å¯é ï¼Œå› ä¸ºæˆ‘ä¹Ÿåªæ˜¯æƒ³å†™ä¸ª Demo è€Œå·²ï¼Œæ­£å¸¸æ¥è¯´è¿˜æ˜¯åº”è¯¥ä½¿ç”¨ OkHttp**

```kotlin
/**
 * @Author: leavesCZY
 * @Githubï¼šhttps://github.com/leavesCZY
 * @Desc:
 */
class VolleyFetcher(private val application: Application) : Fetcher<Uri> {

    override fun handles(data: Uri) = data.scheme == "http" || data.scheme == "https"

    override fun key(data: Uri): String? {
        return data.toString()
    }

    private class ImageRequest(url: String, private val listener: RequestFuture<BufferedSource>) :
        Request<BufferedSource>(Method.GET, url, listener) {
        override fun parseNetworkResponse(response: NetworkResponse): Response<BufferedSource> {
            return Response.success(
                Buffer().write(response.data),
                HttpHeaderParser.parseCacheHeaders(response)
            )
        }

        override fun deliverResponse(response: BufferedSource) {
            listener.onResponse(response)
        }
    }

    override suspend fun fetch(
        pool: BitmapPool,
        data: Uri,
        size: Size,
        options: Options
    ): FetchResult {
        val url = data.toString()
        val newFuture = RequestFuture.newFuture<BufferedSource>()
        val request = ImageRequest(url, newFuture)
        newFuture.setRequest(request)
        Volley.newRequestQueue(application).apply {
            add(request)
            start()
        }
        val get = newFuture.get()
        return SourceResult(
            source = get,
            mimeType = "",
            dataSource = DataSource.NETWORK
        )
    }

}
```

ç„¶åä¸º ImageLoader æ³¨å†Œè¯¥ Fetcher å³å¯

```kotlin
fun init(application: Application) {
    val okHttpClient = createOkHttp(application)
    Coil.setImageLoader(
        ImageLoader.Builder(application)
            .placeholder(ActivityCompat.getDrawable(application, R.drawable.icon_loading))
            .error(ActivityCompat.getDrawable(application, R.drawable.icon_error))
            .memoryCachePolicy(CachePolicy.ENABLED)
            .callFactory(okHttpClient)
            .componentRegistry(
                ComponentRegistry.Builder()
                    .add(VolleyFetcher(application))
                    .add(OkHttpFetcher(okHttpClient)).build()
            )
            .build()
    )
}
```

# åä¸‰ã€GitHub

ä¸Šè¿°çš„æ‰€æœ‰ç¤ºä¾‹ä»£ç æˆ‘éƒ½æ”¾åˆ° GitHub äº†ï¼Œæ¬¢è¿ starï¼š[AndroidOpenSourceDemo](https://github.com/leavesCZY/AndroidOpenSourceDemo)