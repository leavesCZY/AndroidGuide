> å…¬ä¼—å·ï¼š[å­—èŠ‚æ•°ç»„](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adbc507fc3704fd8955aae739a433db2~tplv-k3u1fbpfcp-zoom-1.image)
>
> å¸Œæœ›å¯¹ä½ æœ‰æ‰€å¸®åŠ© ğŸ¤£ğŸ¤£

æœ€è¿‘çœ‹äº† äº¬ä¸œé›¶å”®æŠ€æœ¯ å‘è¡¨çš„ä¸€ç¯‡æ–‡ç« ï¼š[AOP æŠ€æœ¯åœ¨ APP å¼€å‘ä¸­çš„å¤šåœºæ™¯å®è·µ](https://mp.weixin.qq.com/s?__biz=MzUyMDAxMjQ3Ng==&mid=2247497288&idx=1&sn=a3aa54ab49f428106037886462c72335&chksm=f9f2619bce85e88dbc95d76f3a3528f2948687e38c75eedf9e2dee4c39d38e2910737fa0d847&scene=178&cur_album_id=1844068124342484996#rd) ï¼Œæ–‡ç« ä¸­ä»‹ç»äº† AOP æŠ€æœ¯çš„ä¸€ç§ä½¿ç”¨åœºæ™¯ï¼šçº¿ç¨‹ä½¿ç”¨æ•°ä¼˜åŒ–ã€‚çœ‹å®Œä¹‹åæ„Ÿè§‰æŒºæœ‰å®è·µæ„ä¹‰çš„ï¼Œä½†æ–‡ç« ä¸­å¹¶æ²¡æœ‰ç»™å‡ºå…·ä½“çš„å®ç°ä»£ç ï¼Œæ‰€ä»¥æˆ‘å°±åšäº†ä¸€æ¬¡å®æ“ï¼ŒåŸºæœ¬å®ç°äº†æ–‡ç« ä¸­ä»‹ç»çš„æ•ˆæœï¼Œæœ¬æ–‡å°±æ¥è¯¦ç»†ä»‹ç»ä¸‹æˆ‘çš„å®ç°å§‹æœ«ï¼Œå¹¶ç»™å‡ºå…·ä½“çš„å®ç°ä»£ç ã€‚æœ¬æ–‡éƒ¨åˆ†å†…å®¹ä¹Ÿç›´æ¥å¼•ç”¨è‡ªè¯¥æ–‡ç« ï¼Œåœ¨æ­¤è¡¨ç¤ºæ„Ÿè°¢

åœ¨å®ç° Android ç«¯ APP ç¨³å®šæ€§æ²»ç†çš„è¿‡ç¨‹ä¸­ï¼Œå’Œçº¿ç¨‹ç›¸å…³çš„ OOM é—®é¢˜éƒ½æ˜¯é¿å…ä¸äº†çš„ã€‚çº¿ç¨‹æ˜¯ä¸€ç§æ˜‚è´µçš„ç³»ç»Ÿèµ„æºï¼Œå…¶â€œæ˜‚è´µâ€ä¸ä»…åœ¨äºåˆ›å»ºçº¿ç¨‹æ‰€éœ€è¦çš„èµ„æºå¼€é”€ï¼Œè¿˜åœ¨äºä½¿ç”¨è¿‡ç¨‹ä¸­å¸¦æ¥çš„èµ„æºæ¶ˆè€—ã€‚ä¸€ä¸ªç³»ç»Ÿèƒ½å¤Ÿæ”¯æŒåŒæ—¶è¿è¡Œçš„çº¿ç¨‹æ€»æ•°å—é™äºè¯¥ç³»ç»Ÿæ‰€æ‹¥æœ‰çš„å¤„ç†å™¨æ•°ç›®å’Œå†…å­˜å¤§å°ç­‰ç¡¬ä»¶æ¡ä»¶ï¼Œçº¿ç¨‹çš„è¿è¡Œéœ€è¦å ç”¨å¤„ç†å™¨æ—¶é—´ç‰‡ï¼Œç³»ç»Ÿä¸­å¤„äºè¿è¡ŒçŠ¶æ€çš„çº¿ç¨‹è¶Šå¤šï¼Œæ¯ä¸ªçº¿ç¨‹å•ä½æ—¶é—´å†…èƒ½åˆ†é…åˆ°çš„æ—¶é—´ç‰‡å°±ä¼šè¶Šå°‘ï¼Œçº¿ç¨‹è°ƒåº¦å¸¦æ¥çš„ä¸Šä¸‹æ–‡åˆ‡æ¢çš„æ¬¡æ•°å°±ä¼šè¶Šå¤šï¼Œæœ€ç»ˆå¯¼è‡´å¤„ç†å™¨çœŸæ­£ç”¨äºè¿ç®—çš„æ—¶é—´å°±ä¼šè¶Šå°‘ã€‚æ­¤å¤–ï¼Œåœ¨ç°å®åœºæ™¯ä¸­ä¸€ä¸ªç¨‹åºåœ¨å…¶æ•´ä¸ªç”Ÿå‘½å‘¨æœŸå†…éœ€è¦äº¤ç”±çº¿ç¨‹æ‰§è¡Œçš„ä»»åŠ¡æ•°é‡å¾€å¾€æ˜¯è¿œå¤šäºç³»ç»Ÿæ‰€èƒ½æ”¯æŒåŒæ—¶è¿è¡Œçš„æœ€å¤§çº¿ç¨‹æ•°ï¼Œå¦‚æœçº¿ç¨‹æ•°ä¸æ–­ç´¯åŠ çš„è¯å°±ä¼šä¸å¯é¿å…åœ°æŠ›å‡º OOMã€‚å½“çº¿ç¨‹æ•°é‡è¶…è½½æ—¶å°±ä¼šåœ¨å®‰å“è™šæ‹Ÿæœºå±‚æŠ›å‡ºå¼‚å¸¸ï¼š`java.lang.OutOfMemoryError: pthread_create (1040KB stack) failed`

ç”±äºçº¿ç¨‹æ•°è¶…è½½å¯¼è‡´ OOM çš„åŸå› å¯ä»¥å½’ç±»ä¸ºä¸‰ç§ï¼š

- çº¿ç¨‹æ± æ•°é‡è¿‡å¤šã€‚æ¯ä¸ªçº¿ç¨‹æ± éƒ½éœ€è¦å®ˆæŠ¤çº¿ç¨‹ä»¥åŠè¿‡å¤šçš„ç©ºé—´å¼€é”€ï¼Œè¿‡å¤šçš„çº¿ç¨‹æ± ä½¿ç”¨å¯¹äºå†…å­˜èµ„æºæ¶ˆè€—è¿‡å¤§
- å¸¸é©»çº¿ç¨‹è¿‡å¤šã€‚å¸¸é©»çº¿ç¨‹æŒ‡çš„æ˜¯å¤„äº waitingï¼ˆç­‰å¾…ï¼‰ã€blockedï¼ˆé˜»å¡ï¼‰ä»¥åŠ runnableï¼ˆè¿è¡Œï¼‰çš„çº¿ç¨‹ï¼Œè¿™åœ¨ä½¿ç”¨äº†çº¿ç¨‹æ± æ—¶æ¯”è¾ƒå®¹æ˜“å‡ºç°ã€‚æ¯ä¸ªçº¿ç¨‹æ± ä¼šåŒ…å«æœ‰ä¸€å®šæ•°é‡çš„æ ¸å¿ƒçº¿ç¨‹å’Œéæ ¸å¿ƒçº¿ç¨‹ï¼Œé»˜è®¤æƒ…å†µä¸‹æ ¸å¿ƒçº¿ç¨‹å³ä½¿å¤„äºé—²ç½®çŠ¶æ€ä¹Ÿæ˜¯ä¸ä¼šè¢«å›æ”¶çš„ï¼Œå³é»˜è®¤ä¸å— KeepAliveTime å±æ€§çš„é™åˆ¶ï¼Œè¿™ä½¿å¾—æ ¸å¿ƒçº¿ç¨‹æœ‰å¯èƒ½ä¸€ç›´å¤„äºé—²ç½®çŠ¶æ€å¾—ä¸åˆ°é‡Šæ”¾ï¼Œæå¤§æµªè´¹ç³»ç»Ÿèµ„æº
- å¤§é‡çš„åŒ¿åçº¿ç¨‹ã€‚åŒ¿åçº¿ç¨‹æŒ‡çš„æ˜¯åœ¨ä»£ç ä¸­éšå¤„å¯åŠ¨çš„çº¿ç¨‹ï¼Œè¿™ç§æ–¹å¼è™½ç„¶å¯ä»¥å®ç°å¿«é€Ÿã€ä¼˜å…ˆçº§æœ€é«˜çš„å¼‚æ­¥åŒ–ï¼Œä½†è¿‡å¤šçš„åŒ¿åçº¿ç¨‹å¯¹äºé—®é¢˜æ’æŸ¥éš¾åº¦ã€ç¨³å®šæ€§éƒ½æ˜¯ä¸€ç§æŒ‘æˆ˜

å¯¹äºä¸€ä¸ªç»è¿‡é•¿ä¹…è¿­ä»£çš„é¡¹ç›®æ¥è¯´ï¼Œä»¥ä¸Šé—®é¢˜ä¸ä»…ä»…ä¼šå‡ºç°åœ¨è‡ªç ”ä¸šåŠ¡ä¸­ï¼ŒåŒæ—¶è¿˜ä¼šæ¶‰åŠåˆ°å¤šä¸ªä¸‰æ–¹ SDK æˆ–è€…æ˜¯å¼€æºåº“ï¼Œè€Œæƒ³è¦åŒæ—¶æ¨åŠ¨ä¸‰æ–¹ SDK å’Œå¼€æºåº“è¿›è¡Œçº¿ç¨‹ä¼˜åŒ–æ˜¯ä¸å¤ªç°å®çš„ï¼Œæ­¤æ—¶é‡‡ç”¨å­—èŠ‚ç æ’æ¡©è¿™ç§ä¸å±€é™äºç‰¹å®šä¸šåŠ¡å½¢æ€å’Œéä¾µå…¥å¼çš„æ–¹å¼å°±æˆäº†æ¯”è¾ƒé è°±çš„ä¸€ç§é€‰æ‹©

è¿›è¡Œçº¿ç¨‹æ•´æ²»æƒ³è¦å®ç°çš„æ•ˆæœæœ‰ä¸¤ç‚¹ï¼š

- å°†å„ä¸ªåŒ¿åçº¿ç¨‹è¿›è¡Œç»Ÿä¸€å‘½åï¼Œå‘½åè§„åˆ™ï¼šåˆ›å»ºçº¿ç¨‹æ—¶æ‰€åœ¨ç±»çš„ç±»å + ä¸æ–­é€’å¢çš„çº¿ç¨‹å· + åŸå§‹ä»£ç ä¸­è®¾ç½®çš„çº¿ç¨‹åï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ï¼Œæ–¹ä¾¿å‡ºç°å¼‚å¸¸æ—¶èƒ½å¤Ÿå¿«é€Ÿå®šä½é—®é¢˜æ‰€åœ¨
- ç»Ÿä¸€å„ç±»çº¿ç¨‹æ± çš„è¶…æ—¶æœºåˆ¶ã€‚å¯¹ Executors ä¸­çš„å„ä¸ª newXXXXThreadPool è¿›è¡Œ hookï¼Œå°†çº¿ç¨‹æ± ä¸­çš„æ¯ä¸ªçº¿ç¨‹å‡æŒ‰ç…§åŒ¿åçº¿ç¨‹çš„è§„åˆ™è¿›è¡Œå‘½åï¼Œä¸ºçº¿ç¨‹è®¾ç½®ç»Ÿä¸€çš„è¶…æ—¶æ—¶é—´ï¼Œä¸”å…è®¸å›æ”¶æ ¸å¿ƒçº¿ç¨‹

# ä¸€ã€åŒ¿åçº¿ç¨‹

å…ˆéšæ„å£°æ˜ä¸€ä¸ª Thread å¯¹è±¡ï¼Œå¯¹åº”åœ¨é¡¹ç›®ä¸­å­˜åœ¨çš„å„ç±»åŒ¿åçº¿ç¨‹

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd3b413c83b74d829f8aafb4d23bb957~tplv-k3u1fbpfcp-zoom-1.image)

åç¼–è¯‘æŸ¥çœ‹å¯¹åº”çš„å­—èŠ‚ç æŒ‡ä»¤

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/289fdaca979247a283be676c2d7d694b~tplv-k3u1fbpfcp-zoom-1.image)

ä»å½“ä¸­å°±å¯ä»¥çœ‹å‡ºå‡ ç‚¹ä¿¡æ¯ï¼š

- ç¬¬ 23 è¡Œåˆ°ç¬¬ 27 è¡Œå°±å¯¹åº”è°ƒç”¨ `new Thread(Runnable , String)` è¿™ä¸ªè¿‡ç¨‹
- ç¬¬ 23 è¡Œçš„ new æŒ‡ä»¤æ˜ç¡®æŒ‡å‘äº† java/lang/Thread
- ç¬¬ 26 è¡Œçš„ ldc æŒ‡ä»¤ä»£è¡¨çš„æ˜¯ä»å¸¸é‡æ± ä¸­è·å–å¸¸é‡å€¼çš„æ“ä½œï¼Œä¹Ÿå³è·å–çº¿ç¨‹åå­—ç¬¦ä¸² `thread name`
- ç¬¬ 27 è¡Œçš„ invokespecial æŒ‡ä»¤å¯¹åº”çš„æ˜¯è°ƒç”¨ Thread æ„é€ å‡½æ•°çš„è¿‡ç¨‹ï¼ŒåŒ…å«ä¸¤ä¸ªå…¥å‚å‚æ•°

è¯¥åŒ¿åçº¿ç¨‹åœ¨å£°æ˜æ—¶ä¸»åŠ¨è®¾ç½®äº†çº¿ç¨‹åï¼Œè€Œé¡¹ç›®ä¸­å…¶å®ƒåŒ¿åçº¿ç¨‹å¯èƒ½å¹¶æ²¡æœ‰è¿›è¡Œè®¾ç½®ï¼Œè€Œæ˜¯åªä¼ å…¥äº† Runnableã€‚å› æ­¤ï¼Œåœ¨å­—èŠ‚ç å±‚é¢ä¸Šå°±è¦è€ƒè™‘ä¸¤ç§ä¸åŒçš„æŒ‡ä»¤ç»“æ„äº†ï¼š**åŒ…å«ä¸€ä¸ªå…¥å‚å‚æ•°** å’Œ **åŒ…å«ä¸¤ä¸ªå…¥å‚å‚æ•°**

è€Œå¦‚æœè¦åœ¨å­—èŠ‚ç å±‚é¢ä¸Šæ¥æ‰‹åŠ¨ç”Ÿæˆæˆ–è€…æ˜¯æ‹¼æ¥ ThreadName çš„è¯ä¼šæ¯”è¾ƒéº»çƒ¦ï¼Œæ‰€ä»¥æˆ‘é‡‡å–çš„æ˜¯ä¸€ä¸ªæ¯”è¾ƒå·§å¦™çš„æ–¹æ³•ï¼šå°†è¦å£°æ˜çš„ Thread å¯¹è±¡æ›¿æ¢ä¸ºæˆ‘ä»¬è‡ªå®šä¹‰çš„ Thread å­ç±»ï¼Œä¸ºè¯¥å­ç±»å¤šå£°æ˜ä¸€ä¸ªç”¨äºä¼ å…¥ç±»åçš„æ„é€ å‚æ•°ï¼Œé€šè¿‡è¿™ç§æ–¹å¼å°±æ— éœ€å…³å¿ƒåœ¨å£°æ˜ Thread å¯¹è±¡æ—¶åˆ°åº•ä¼ å…¥äº†å‡ ä¸ªæ„é€ å‚æ•°äº†ï¼Œåªéœ€è¦åœ¨è°ƒç”¨ invokespecial æŒ‡ä»¤æ—¶å›ºå®šåœ¨æœ«å°¾å¤šä¼ å…¥ä¸€ä¸ªä»£è¡¨å½“å‰ç±»åçš„ String å‚æ•°å³å¯

æ¥çœ‹ä¸‹å®é™…çš„ç¼–ç å®ç°

å…ˆå®šä¹‰ä¸€ä¸ª Thread å­ç±»ï¼Œä¸ºå…¶å¤šå£°æ˜ä¸€ä¸ªå…¥å‚å‚æ•° classNameï¼Œç„¶åæ‰‹åŠ¨å°† **åŸå§‹ä»£ç ä¸­è®¾ç½®çš„çº¿ç¨‹å** å’Œ **className** æŒ‰ç…§æ—¢å®šè§„åˆ™æ‹¼æ¥åœ¨ä¸€èµ·ä½œä¸ºæœ€ç»ˆçš„çº¿ç¨‹å

```kotlin
/**
 * @Author: leavesCZY
 * @Desc:
 * @å…¬ä¼—å·ï¼šå­—èŠ‚æ•°ç»„
 */
class OptimizedThread(runnable: Runnable?, name: String?, className: String) :
    Thread(runnable, generateThreadName(name, className)) {

    companion object {

        private val threadId = AtomicInteger(0)

        private fun generateThreadName(name: String?, className: String): String {
            return className + "-" + threadId.getAndIncrement() + if (name.isNullOrBlank()) {
                ""
            } else {
                "-$name"
            }
        }

    }

    constructor(runnable: Runnable, className: String) : this(runnable, null, className)

    constructor(name: String, className: String) : this(null, name, className)

}
```

ä¹‹åï¼Œåœ¨ Transform é˜¶æ®µåªè¦éå†åˆ°æŒ‡å‘ `java/lang/Thread ` çš„ TypeInsnNodeï¼Œä¸”ä¸æ˜¯åŒ…å«åœ¨ ThreadFactory å†…éƒ¨çš„è¯ï¼Œé‚£å°±æ˜¯è¦å¤„ç†çš„åŒ¿åçº¿ç¨‹äº†

```kotlin
/**
 * @Author: leavesCZY
 * @Desc:
 * @å…¬ä¼—å·ï¼šå­—èŠ‚æ•°ç»„
 */
class OptimizedThreadTransform(private val config: OptimizedThreadConfig) : BaseTransform() {

    companion object {

        private const val threadClass = "java/lang/Thread"

        private const val threadFactoryClass = "java/util/concurrent/ThreadFactory"

        private const val threadFactoryNewThreadMethodDesc =
            "newThread(Ljava/lang/Runnable;)Ljava/lang/Thread;"

    }

    override fun modifyClass(byteArray: ByteArray): ByteArray {
        val classNode = ClassNode()
        val classReader = ClassReader(byteArray)
        classReader.accept(classNode, ClassReader.EXPAND_FRAMES)
        val methods = classNode.methods
        val taskList = mutableListOf<() -> Unit>()
        if (!methods.isNullOrEmpty()) {
            for (methodNode in methods) {
                val instructionIterator = methodNode.instructions?.iterator()
                if (instructionIterator != null) {
                    while (instructionIterator.hasNext()) {
                        val instruction = instructionIterator.next()
                        when (instruction.opcode) {
                            Opcodes.NEW -> {
                                val typeInsnNode = instruction as? TypeInsnNode
                                if (typeInsnNode?.desc == threadClass) {
                                    //å¦‚æœæ˜¯åœ¨ ThreadFactory å†…åˆå§‹åŒ–çº¿ç¨‹ï¼Œåˆ™ä¸å¤„ç†
                                    if (!classNode.isThreadFactoryMethod(methodNode)) {
                                        taskList.add {
                                            transformNew(
                                                classNode,
                                                methodNode,
                                                instruction
                                            )
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        taskList.forEach {
            it.invoke()
        }
        val classWriter = ClassWriter(ClassWriter.COMPUTE_MAXS)
        classNode.accept(classWriter)
        return classWriter.toByteArray()
    }

    private fun ClassNode.isThreadFactoryMethod(methodNode: MethodNode): Boolean {
        return this.interfaces?.contains(threadFactoryClass) == true
                && methodNode.nameWithDesc == threadFactoryNewThreadMethodDesc
    }

}
```

æ‰¾åˆ°åˆ°ç›®æ ‡æŒ‡ä»¤åï¼Œå°±å°† `java/lang/Thread ` æ›¿æ¢ä¸º OptimizedThreadï¼Œç„¶åç»§ç»­å‘åéå†æ‰¾åˆ°è°ƒç”¨ Thread æ„é€ å‚æ•°çš„æŒ‡ä»¤ï¼Œä¸ºè¯¥æŒ‡ä»¤å¤šæ’å…¥ä¸€ä¸ª String ç±»å‹çš„æ–¹æ³•å…¥å‚å‚æ•°å£°æ˜ï¼Œç„¶åå°† className ä½œä¸ºæ„é€ å‚æ•°ä¼ ç»™ OptimizedThreadï¼Œè‡³æ­¤å°±å®Œæˆæ›¿æ¢äº†

```kotlin
private fun transformNew(
    classNode: ClassNode,
    methodNode: MethodNode,
    typeInsnNode: TypeInsnNode
) {
    val instructions = methodNode.instructions
    val typeInsnNodeIndex = instructions.indexOf(typeInsnNode)
    //ä» typeInsnNode æŒ‡ä»¤å¼€å§‹éå†ï¼Œæ‰¾åˆ°è°ƒç”¨ Thread æ„é€ å‡½æ•°çš„æŒ‡ä»¤ï¼Œç„¶åå¯¹å…¶è¿›è¡Œæ›¿æ¢
    for (index in typeInsnNodeIndex + 1 until instructions.size()) {
        val node = instructions[index]
        if (node is MethodInsnNode && node.isThreadInitMethodInsn()) {
            //å°† Thread æ›¿æ¢ä¸º OptimizedThread
            typeInsnNode.desc = config.formatOptimizedThreadClass
            node.owner = config.formatOptimizedThreadClass
            //ä¸ºè°ƒç”¨ Thread æ„é€ å‡½æ•°çš„æŒ‡ä»¤å¤šæ’å…¥ä¸€ä¸ª String ç±»å‹çš„æ–¹æ³•å…¥å‚å‚æ•°å£°æ˜
            node.insertArgument(String::class.java)
            //å°† ClassName ä½œä¸ºæ„é€ å‚æ•°ä¼ ç»™ OptimizedThread
            instructions.insertBefore(node, LdcInsnNode(classNode.simpleClassName))
            break
        }
    }
}
```

# äºŒã€çº¿ç¨‹æ± 

`java.util.concurrent.Executors` ç±»ä¸­ç”¨äºè·å–çº¿ç¨‹æ± çš„æ–¹æ³•æœ‰åäºŒä¸ªä¹‹å¤š

```java
public class Executors {

    public static ExecutorService newFixedThreadPool(int nThreads)

    public static ExecutorService newWorkStealingPool(int parallelism)

    public static ExecutorService newWorkStealingPool()

    public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)

    public static ExecutorService newSingleThreadExecutor()

    public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)

    public static ExecutorService newCachedThreadPool()

    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)

    public static ScheduledExecutorService newSingleThreadScheduledExecutor()

    public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)

    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)

    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)

}
```

è¿™åäºŒä¸ªé™æ€æ–¹æ³•æŒ‰ç…§å…¥å‚å‚æ•°æ¥è¿›è¡ŒåŒºåˆ†çš„è¯æœ‰ä¸‰ç§ï¼š

- ä¸åŒ…å«å…¥å‚å‚æ•°
- åŒ…å«ä¸€ä¸ªå…¥å‚å‚æ•°ï¼šä»£è¡¨çº¿ç¨‹æ•°çš„ int ç±»å‹æˆ–è€…æ˜¯ ThreadFactory
- åŒ…å«ä¸¤ä¸ªå…¥å‚å‚æ•°ï¼šä»£è¡¨çº¿ç¨‹æ•°çš„ int ç±»å‹åŠ  ThreadFactory

æŒ‰ç…§è¿”å›å€¼æ¥è¿›è¡ŒåŒºåˆ†çš„è¯æœ‰ä¸¤ç§ï¼š

- ExecutorService
- ScheduledExecutorService

åœ¨è¿›è¡Œ hook çš„æ—¶å€™å°±éœ€è¦è€ƒè™‘å¯¹åº”ä»£ç ä¼ å…¥äº†å¤šå°‘ä¸ªå…¥å‚å‚æ•°ä»¥åŠæ–¹æ³•çš„è¿”å›å€¼ç±»å‹äº†ã€‚ä¸ºäº†ç»Ÿä¸€çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹å‘½åè§„åˆ™ï¼Œå°±éœ€è¦æ›¿æ¢ä¼ å…¥çš„ ThreadFactoryï¼Œå¹¶ä¸”ä¼ å…¥ä»£è¡¨å½“å‰ç±»åçš„ String å‚æ•°ã€‚ä¸ºäº†èƒ½å¤Ÿä¸ºçº¿ç¨‹è®¾ç½®ç»Ÿä¸€çš„è¶…æ—¶æ—¶é—´ï¼Œä»¥åŠå…è®¸å›æ”¶æ ¸å¿ƒçº¿ç¨‹ï¼Œå°±éœ€è¦èƒ½å¤Ÿè·å–åˆ° ThreadPoolExecutor å¯¹è±¡äº†

JDK ä¸­çš„æºç æˆ‘ä»¬æ˜¯æ²¡æ³•è¿›è¡Œ hook çš„ï¼Œè€Œå¦‚æœè¦åœ¨å­—èŠ‚ç å±‚é¢ä¸Šæ¥è¿›è¡Œä»¥ä¸Šä¿®æ”¹çš„è¯ä¼šæ¯”è¾ƒéº»çƒ¦ï¼Œæ‰€ä»¥æˆ‘é‡‡å–çš„æ˜¯å’Œå¤„ç†åŒ¿åçº¿ç¨‹æ—¶ç±»ä¼¼çš„æ€è·¯ï¼šå£°æ˜ä¸€ä¸ª OptimizedExecutors ç±»ï¼Œå…ˆåœ¨å½“ä¸­å£°æ˜å’Œ Executors ä¸­å„ç±» `newXXXThreadPool` ç­¾åä¿¡æ¯ä¸€è‡´çš„æ–¹æ³•ï¼Œç„¶åå†ä¸ºæ¯ä¸ªæ–¹æ³•å¤šæ·»åŠ ä¸€ä¸ª String ç±»å‹çš„å…¥å‚å‚æ•°ï¼Œå°†æŒ‡å‘ Executors çš„å­—èŠ‚ç å‡æ”¹ä¸º OptimizedExecutorsï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ OptimizedExecutors ä¸­è‡ªç”±é…ç½®çº¿ç¨‹æ± å‚æ•°äº†

æ¥çœ‹ä¸‹å®é™…çš„ç¼–ç å®ç°

é¦–å…ˆæ˜¯å®šä¹‰æ‹¿æ¥è¿›è¡Œæ›¿æ¢çš„ OptimizedExecutorsï¼Œä¸ºæ¯ä¸ªç”Ÿæˆçš„ ThreadPoolExecutor ç»Ÿä¸€è®¾ç½®äº”ç§’çš„è¶…æ—¶æ—¶é—´å¹¶å…è®¸å›æ”¶æ ¸å¿ƒçº¿ç¨‹ï¼Œåœ¨ NamedThreadFactory ä¸­å®šä¹‰ç»Ÿä¸€çš„çº¿ç¨‹å‘½åè§„åˆ™

```kotlin
/**
 * @Author: leavesCZY
 * @Desc:
 * @å…¬ä¼—å·ï¼šå­—èŠ‚æ•°ç»„
 */
object OptimizedExecutors {

    private const val defaultThreadKeepAliveTime = 5000L

    @JvmStatic
    fun newFixedThreadPool(nThreads: Int, className: String): ExecutorService {
        return newFixedThreadPool(nThreads, null, className)
    }

    @JvmStatic
    fun newFixedThreadPool(
        nThreads: Int,
        threadFactory: ThreadFactory?,
        className: String
    ): ExecutorService {
        return getOptimizedExecutorService(
            nThreads, nThreads,
            0L, TimeUnit.MILLISECONDS,
            LinkedBlockingQueue(),
            threadFactory, className
        )
    }
    
	Â·Â·Â·

    private fun getOptimizedExecutorService(
        corePoolSize: Int,
        maximumPoolSize: Int,
        keepAliveTime: Long,
        unit: TimeUnit,
        workQueue: BlockingQueue<Runnable>,
        threadFactory: ThreadFactory? = null,
        className: String,
    ): ExecutorService {
        val executor = ThreadPoolExecutor(
            corePoolSize, maximumPoolSize,
            keepAliveTime, unit,
            workQueue,
            NamedThreadFactory(threadFactory, className)
        )
        executor.setKeepAliveTime(defaultThreadKeepAliveTime, TimeUnit.MILLISECONDS)
        executor.allowCoreThreadTimeOut(true)
        return executor
    }

    private class NamedThreadFactory(
        private val threadFactory: ThreadFactory?,
        private val className: String
    ) : ThreadFactory {

        private val threadId = AtomicInteger(0)

        override fun newThread(runnable: Runnable): Thread {
            val originThread = threadFactory?.newThread(runnable)
            val threadName =
                className + "-" + threadId.getAndIncrement() + if (originThread != null) {
                    "-" + originThread.name
                } else {
                    ""
                }
            val thread = originThread ?: Thread(runnable)
            thread.name = threadName
            if (thread.isDaemon) {
                thread.isDaemon = false
            }
            if (thread.priority != Thread.NORM_PRIORITY) {
                thread.priority = Thread.NORM_PRIORITY
            }
            return thread
        }

    }

}
```

ä¹‹åï¼Œåœ¨ Transform é˜¶æ®µåªè¦éå†åˆ°è°ƒç”¨äº† Executors ä¸­é™æ€æ–¹æ³•çš„æŒ‡ä»¤çš„è¯ï¼Œå°±å°†è¯¥æŒ‡ä»¤ä¸­çš„ Executors æ›¿æ¢ä¸º OptimizedExecutorsï¼Œç„¶åæ·»åŠ å¤šæ’å…¥çš„å‚æ•°

```kotlin
/**
 * @Author: leavesCZY
 * @Desc:
 * @å…¬ä¼—å·ï¼šå­—èŠ‚æ•°ç»„
 */
class OptimizedThreadTransform(private val config: OptimizedThreadConfig) : BaseTransform() {

    companion object {

        private const val executorsClass = "java/util/concurrent/Executors"

    }

    override fun modifyClass(byteArray: ByteArray): ByteArray {
        val classNode = ClassNode()
        val classReader = ClassReader(byteArray)
        classReader.accept(classNode, ClassReader.EXPAND_FRAMES)
        val methods = classNode.methods
        val taskList = mutableListOf<() -> Unit>()
        if (!methods.isNullOrEmpty()) {
            for (methodNode in methods) {
                val instructionIterator = methodNode.instructions?.iterator()
                if (instructionIterator != null) {
                    while (instructionIterator.hasNext()) {
                        val instruction = instructionIterator.next()
                        when (instruction.opcode) {
                            Opcodes.INVOKESTATIC -> {
                                val methodInsnNode = instruction as? MethodInsnNode
                                if (methodInsnNode?.owner == executorsClass) {
                                    taskList.add {
                                        transformInvokeStatic(
                                            classNode,
                                            methodNode,
                                            instruction
                                        )
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        taskList.forEach {
            it.invoke()
        }
        val classWriter = ClassWriter(ClassWriter.COMPUTE_MAXS)
        classNode.accept(classWriter)
        return classWriter.toByteArray()
    }

    private fun transformInvokeStatic(
        classNode: ClassNode,
        methodNode: MethodNode,
        methodInsnNode: MethodInsnNode
    ) {
        val pointMethod = config.threadHookPointList.find { it.methodName == methodInsnNode.name }
        if (pointMethod != null) {
            //å°† Executors æ›¿æ¢ä¸º OptimizedExecutors
            methodInsnNode.owner = config.formatOptimizedThreadPoolClass
            //ä¸ºè°ƒç”¨ newFixedThreadPool ç­‰æ–¹æ³•çš„æŒ‡ä»¤å¤šæ’å…¥ä¸€ä¸ª String ç±»å‹çš„æ–¹æ³•å…¥å‚å‚æ•°å£°æ˜
            methodInsnNode.insertArgument(String::class.java)
            //å°† ClassName ä½œä¸ºå…¥å‚å‚æ•°ä¼ ç»™ newFixedThreadPool ç­‰æ–¹æ³•
            methodNode.instructions.insertBefore(
                methodInsnNode,
                LdcInsnNode(classNode.simpleClassName)
            )
        }
    }

}
```

# ä¸‰ã€éœ€æ…é‡

éœ€è¦æ³¨æ„ï¼Œä¸Šè¿°çš„æ‰‹æ®µå¹¶ä¸å…¨æ˜¯å¯ä»¥åœ¨é¡¹ç›®ä¸­è¿›è¡Œå…¨ç›˜å¥—ç”¨çš„

ä¸ºçº¿ç¨‹è®¾ç½®ä¸€ä¸ªç»Ÿä¸€å’Œå®¹æ˜“æ ‡è¯†çš„çº¿ç¨‹åæœ‰åˆ©äºå‡ºç°å¼‚å¸¸æ—¶èƒ½å¤Ÿå¿«é€Ÿå®šä½é—®é¢˜ï¼Œè¿™æ˜¯æ¯”è¾ƒæœ‰æ„ä¹‰çš„ã€‚ä½†ä¸ºçº¿ç¨‹æ± è®¾ç½®ç»Ÿä¸€çš„è¶…é•¿æ—¶é—´å’Œå…è®¸å›æ”¶æ ¸å¿ƒçº¿ç¨‹ï¼Œè¿™æ˜¯éœ€è¦è€ƒè™‘ä½¿ç”¨åœºæ™¯çš„ï¼Œè®¾ç½®ä¸å½“åè€Œå¯èƒ½ä¼šåŠ å¤§ OOM çš„æ¦‚ç‡

å¦‚æœå¤§éƒ¨åˆ†æƒ…å†µä¸‹çº¿ç¨‹æ± éœ€è¦å¤„ç†çš„ä»»åŠ¡æ¯”è¾ƒå°‘ä¸”åˆä¸å…è®¸å›æ”¶æ ¸å¿ƒçº¿ç¨‹çš„è¯ï¼Œå°±ä¼šå¯¼è‡´æ ¸å¿ƒçº¿ç¨‹å¤§éƒ¨åˆ†æ—¶é—´å¤„äºé˜»å¡çŠ¶æ€å¾—ä¸åˆ°é‡Šæ”¾ï¼Œæµªè´¹ç³»ç»Ÿèµ„æºï¼Œæ­¤æ—¶é€šè¿‡ hook æ¥å…è®¸å›æ”¶æ ¸å¿ƒçº¿ç¨‹æ˜¯æ¯”è¾ƒæœ‰æ„ä¹‰çš„ã€‚è€Œå¦‚æœçº¿ç¨‹æ± éœ€è¦å¤„ç†çš„ä»»åŠ¡æ˜¯å±äºå®šæ—¶æ‰§è¡Œçš„è¯ï¼Œä¾‹å¦‚å›ºå®šæ¯å…­ç§’å°±ä¼šæœ‰ä¸€ä¸ªæ–°ä»»åŠ¡åˆ°æ¥ï¼Œæ­¤æ—¶é€šè¿‡ hook è®¾ç½®äº†çº¿ç¨‹è¶…æ—¶æ—¶é—´ä¸ºäº”ç§’ï¼Œé‚£å°±æœ‰å¯èƒ½å¯¼è‡´çº¿ç¨‹åˆšè¢«å›æ”¶ä¸ä¹…åˆéœ€è¦é‡æ–°åˆ›å»ºäº†ï¼Œè¿™ç§åå¤çš„åˆ›å»ºå’Œå›æ”¶åè€ŒåŠ å¤§äº†ç³»ç»Ÿå¼€é”€ï¼Œåè€Œä¸å¦‚ç›´æ¥å…è®¸æ ¸å¿ƒçº¿ç¨‹å¸¸é©»ã€‚æ­¤å¤–ï¼Œçº¿ç¨‹ä»è¢«åˆ›å»ºåˆ°è¢«ç³»ç»Ÿé€‰ä¸­è°ƒåº¦æ‰§è¡Œæ˜¯æœ‰ä¸€å®šè€—æ—¶çš„ï¼Œè¿™ä¸é€‚åˆäºæŸäº›å¯¹å“åº”é€Ÿåº¦è¦æ±‚æ¯”è¾ƒé«˜çš„åœºæ™¯ï¼Œæ­¤æ—¶å…è®¸å›æ”¶æ ¸å¿ƒçº¿ç¨‹ä¹Ÿæ˜¯ä¸å¤ªåˆé€‚çš„

æ‰€ä»¥è¯´ï¼Œåœ¨é’ˆå¯¹çº¿ç¨‹æ± è¿›è¡Œæ•´æ²»çš„æ—¶å€™ï¼Œéœ€è¦åŒæ—¶è€ƒè™‘è¯¥çº¿ç¨‹æ± æ˜¯åº”ç”¨äºä»€ä¹ˆä¸šåŠ¡åœºæ™¯ï¼Œæ ¹æ®ç”¨é€”æ¥è¿›è¡Œç‰¹æ®Šé…ç½®

å…³äºçº¿ç¨‹æ± çš„å®ç°ç»†èŠ‚ï¼Œå¯ä»¥çœ‹æˆ‘å†™çš„ä¸€ç¯‡ ThreadPoolExecutor è§£è¯»æ–‡ç« ï¼Œå¯¹è®¾è®¡åˆè¡·å’Œå®ç°å§‹æœ«è¿›è¡Œäº†è¯¦ç»†ä»‹ç»ï¼š[èŠèŠ Java å¤šçº¿ç¨‹ï¼ˆ5ï¼‰-è¶…è¯¦ç»†çš„ ThreadPoolExecutor æºç è§£æ](https://juejin.cn/post/6901317365561032712)

# å››ã€æºç 

æœ€åä¹Ÿç»™å‡ºå®Œæ•´çš„æºç ï¼š[ASM_Transform](https://github.com/leavesCZY/ASM_Transform)